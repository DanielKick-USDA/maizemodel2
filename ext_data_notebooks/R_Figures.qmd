---
jupyter:
  jupytext:
    formats: 'ipynb,qmd'
  kernelspec:
    display_name: R
    language: R
    name: ir
---

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:03.882212Z', start_time: '2023-07-13T19:11:02.723Z'}
#| scrolled: true
library(drc)
library(tidyverse)
library(patchwork)
library(ggrepel)
# library(cowplot)
library(ggrastr)
library(VCA)
ggplot2::theme_set(theme_minimal())
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:03.905390Z', start_time: '2023-07-13T19:11:02.726Z'}
# install.packages("drc")
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:03.912344Z', start_time: '2023-07-13T19:11:02.729Z'}
overwrite_saved_files <- FALSE
```

# Figure 1

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:03.919933Z', start_time: '2023-07-13T19:11:02.733Z'}
fig1_ylim = c(0.825, 1.14)
#            Min                Max
#       Raw  0.857902419696555  1.13000518877101
# Ensembled  0.827244808392623  1.13000518877101


```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:03.981436Z', start_time: '2023-07-13T19:11:02.737Z'}
Figure1_Data_1Mod <- read.csv("../output/Figure1_Data_1Mod.csv")
Figure1_Data_1Mod %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:03.988166Z', start_time: '2023-07-13T19:11:02.742Z'}
# Figure1_Data_1Mod  <- Figure1_Data_1Mod[!is.na(Figure1_Data_1Mod$model), ]
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.012894Z', start_time: '2023-07-13T19:11:02.747Z'}
standardize_dat <- function(M){
    M <- M %>% 
      mutate(model = 
               case_when(
                model == "knn" ~ "KNN",
                model == "rf" ~ "RF",
                model == "rnr" ~ "RNR",
                model == "svrl" ~ "SVR",
                model == "DNN-Con." ~ "DNN-CO",
                model == "cat" ~ "DNN-CO",
                   
                model == "DNN-Sim." ~ "DNN-SO",                   
                model == "full" ~ "DNN-SO",

                model == "lm" ~ "LM",            

                model == "BLUP" ~ "BLUP",
                model == "bglr" ~ "BLUP",
                model == "Training Mean" ~ "Mean"
    ))

    # order the facets
    M$model <- factor(M$model, levels = c(
      "Mean", "LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO"))

    if(!('model_class' %in% names(M))){
        M <- M %>% 
          mutate(model_class = 
                   case_when(
                    model == "KNN" ~ "ML",
                    model == "RF" ~ "ML",
                    model == "RNR" ~ "ML",
                    model == "SVR" ~ "ML",
                    model == "DNN-CO" ~ "DNN",
                    model == "DNN-SO" ~ "DNN",

                    model == "LM" ~ "LM",            

                    model == "BLUP" ~ "BLUP",
                    model == "Mean" ~ "LM"
        ))        
    }
    
    M$model_class <- factor(M$model_class, levels = c("LM", "BLUP", "ML", "DNN"))
    # M$data_source <- factor(M$data_source, levels = c("G", "S", "W", "Multi"))
    return(M)    
}
Figure1_Data_1Mod <- standardize_dat(Figure1_Data_1Mod)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.020518Z', start_time: '2023-07-13T19:11:02.751Z'}
Figure1_Data_1Mod <- Figure1_Data_1Mod[!is.na(Figure1_Data_1Mod$model), ]
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.046488Z', start_time: '2023-07-13T19:11:02.755Z'}
fig1_orig_mods <- ggplot(Figure1_Data_1Mod, aes(model, test_rmse))+
    geom_boxplot(aes(fill = model_class))+
    scale_fill_brewer(type = "qual", palette = "Set2")+
    labs(y = '')+
    theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = 'none')+
    coord_cartesian(ylim = fig1_ylim)
# fig1_orig_mods
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.059016Z', start_time: '2023-07-13T19:11:02.760Z'}
temp <- read.csv("../output/Figure1_Data_Heatmap.csv")
# temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.297538Z', start_time: '2023-07-13T19:11:02.764Z'}
temp <- temp %>% 
    separate(Model1, c("model", "num"), "_") %>% 
    mutate(model = 
        case_when(
            model == "knn" ~ "KNN",
            model == "rf" ~ "RF",
            model == "rnr" ~ "RNR",
            model == "svrl" ~ "SVR",
            model == "cat" ~ "DNN-CO",
            model == "full" ~ "DNN-SO",

            model == "lm" ~ "LM",            

            model == "bglr" ~ "BLUP",
            model == "Training Mean" ~ "Mean" )) %>% 
#     mutate(model1 = model) %>% 
    unite(Model1, model:num,  sep = "_", remove = TRUE) %>% 
    separate(Model2, c("model", "num"), "_") %>% 
    mutate(model = 
        case_when(
            model == "knn" ~ "KNN",
            model == "rf" ~ "RF",
            model == "rnr" ~ "RNR",
            model == "svrl" ~ "SVR",
            model == "cat" ~ "DNN-CO",
            model == "full" ~ "DNN-SO",

            model == "lm" ~ "LM",            

            model == "bglr" ~ "BLUP",
            model == "Training Mean" ~ "Mean" )) %>% 
#     mutate(model2 = model) %>% 
    unite(Model2, model:num,  sep = "_", remove = TRUE)

# separate_wider_delim(Model1, "_", names = c("A", "B"))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.306892Z', start_time: '2023-07-13T19:11:02.769Z'}
mods <- c("Mean", "LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO")
reps <- 0:9
mod_reps <- paste(rep(mods, each = length(reps)),
                  rep(reps, time = length(mods)), sep = '_')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.315199Z', start_time: '2023-07-13T19:11:02.775Z'}
temp$Model1 <- factor(temp$Model1, levels = mod_reps)
temp$Model2 <- factor(temp$Model2, levels = mod_reps)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.346453Z', start_time: '2023-07-13T19:11:02.779Z'}
options(repr.plot.width=16, repr.plot.height=10)

add_lines_at = 0.5+(10*1:8)

fig1_heatmap <- ggplot(temp, aes(x = Model1, y = Model2, fill = RMSE))+
    geom_tile()+
    scale_fill_viridis_c()+
    coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")+
    theme(axis.text.x = element_text(angle = 90, hjust = 1))+
    geom_hline(yintercept = add_lines_at, color = 'white')+
    geom_vline(xintercept = add_lines_at, color = 'white')
# fig1_heatmap 
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.454201Z', start_time: '2023-07-13T19:11:02.784Z'}
# are there any cases where a single model is better than all it's possible ensembles?
# diagonal < off

test_mod = 'LM_0'

single_mods <- unique(temp$Model1)

ens_pr_better <- map(single_mods, function(test_mod){
    single_mod_mask <- ((temp$Model1 == test_mod) & (temp$Model2 == test_mod))
    single_mod <- temp[single_mod_mask, 'RMSE']

    # only considering Model1 to 'shave' the matrix
    ens <- temp[(!single_mod_mask & (temp$Model1 == test_mod)) , ] 
    
    # % ens better
    return(mean(ens$RMSE < single_mod))    
}) %>% unlist()

ens_pr <- data.frame(single_mods, ens_pr_better)  %>% 
    mutate(ens_n_better = (79*ens_pr_better)) %>% 
    arrange(ens_pr_better)
ens_pr %>% head()
ens_pr %>% tail(n = 15)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.467530Z', start_time: '2023-07-13T19:11:02.789Z'}
# include table in supplement

ens_pr %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.483620Z', start_time: '2023-07-13T19:11:02.795Z'}
ens_pr['Model'] <- stringr::str_extract(ens_pr$single_mods, '\\D+') %>% stringr::str_remove('_')
ens_pr %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.509166Z', start_time: '2023-07-13T19:11:02.800Z'}
ens_pr %>% 
    summarise(
        ens_pr_better = mean(ens_pr_better),
        ens_n_better = mean(ens_n_better)
    )


# include table
ens_pr %>% 
    group_by(Model) %>% 
    summarise(
        ens_pr_better = mean(ens_pr_better),
        ens_n_better = mean(ens_n_better)
    ) %>% arrange(ens_pr_better)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.526254Z', start_time: '2023-07-13T19:11:02.804Z'}
temp['Model1'] <- stringr::str_extract(temp$Model1, '\\D+') %>% stringr::str_remove('_')
temp['Model2'] <- stringr::str_extract(temp$Model2, '\\D+') %>% stringr::str_remove('_')
temp['Models'] <- paste0(temp$Model1, '_', temp$Model2)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.539630Z', start_time: '2023-07-13T19:11:02.808Z'}
temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.571266Z', start_time: '2023-07-13T19:11:02.813Z'}
# set to same format as temp
Figure1_Data_1Mod_small <- Figure1_Data_1Mod %>% 
    rename(
        Models = model,
        RMSE = test_rmse) %>% 
    select(-data_source, #-model_class, 
           -replicate)

temp <- full_join(temp, Figure1_Data_1Mod_small)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.588147Z', start_time: '2023-07-13T19:11:02.817Z'}
# Deduplicate equivalent Models
out  <- list()
for(i in seq(1, length(mods))){
    for(j in seq(i, length(mods))){
        if(mods[i] == mods[j]){
            out[length(out)+1] <- mods[i]
        } else {
            out[length(out)+1] <- paste(mods[i], mods[j], sep = '_')
        }
    }
}
temp <- temp[temp$Models %in% out, ]
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.611213Z', start_time: '2023-07-13T19:11:02.822Z'}
temp <- temp %>% 
    group_by(Models) %>% 
    mutate(AveRMSE = mean(RMSE)) %>% 
    ungroup() %>% 
    arrange(AveRMSE)
temp$Models <- factor(temp$Models, levels = unique(temp$Models))
temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.154583Z', start_time: '2023-07-13T19:11:02.825Z'}
fig1_ens <- ggplot(temp, aes(Models, RMSE))+
    geom_boxplot(fill = 'lightgray', width=0.7)+
    geom_boxplot(data = Figure1_Data_1Mod_small, aes(fill = model_class, group = Models), width=0.7)+
    geom_boxplot(data = Figure1_Data_1Mod_small[Figure1_Data_1Mod_small$Models %in% c('KNN', 'RNR', 'RF'), ], color = '#8da0cb', width=0.7)+
    labs(x = "")+
    theme(axis.text.x = element_blank(), legend.position = 'none'
         )+
    coord_cartesian(ylim = fig1_ylim)+
    scale_fill_brewer(type = "qual", palette = "Set2")

fig1_ens
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.161493Z', start_time: '2023-07-13T19:11:02.830Z'}
# fig1_ens <- ggplot(temp, aes(Models, RMSE))+
#     geom_boxplot(fill = 'lightgray')+
#     labs(x = "")+
#     theme(axis.text.x = element_blank())+
#     coord_cartesian(ylim = fig1_ylim)
# fig1_ens
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.171005Z', start_time: '2023-07-13T19:11:02.835Z'}
temp$Model1_class <- case_when(
    temp$Model1 %in% c('LM') ~ 'LM',
    temp$Model1 %in% c('BLUP') ~ 'BLUP',
    temp$Model1 %in% c('KNN', 'RNR', 'RF', 'SVR') ~ 'ML',
    temp$Model1 %in% c('DNN-CO', 'DNN-SO') ~ 'DNN'
    )

temp$Model2_class <- case_when(
    temp$Model2 %in% c('LM') ~ 'LM',
    temp$Model2 %in% c('BLUP') ~ 'BLUP',
    temp$Model2 %in% c('KNN', 'RNR', 'RF', 'SVR') ~ 'ML',
    temp$Model2 %in% c('DNN-CO', 'DNN-SO') ~ 'DNN'
    )
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.187063Z', start_time: '2023-07-13T19:11:02.839Z'}
# if there's only one model (not ensembled) then it should be filled in for plotting
temp[is.na(temp$Model1), 'Model1_class'] <- temp[is.na(temp$Model1), 'model_class']
temp[is.na(temp$Model1), 'Model1'] <- temp[is.na(temp$Model1), 'Models']

temp[is.na(temp$Model2), 'Model2_class'] <- temp[is.na(temp$Model2), 'model_class']
temp[is.na(temp$Model2), 'Model2'] <- temp[is.na(temp$Model2), 'Models']
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.195148Z', start_time: '2023-07-13T19:11:02.843Z'}
temp$Model1_class <- factor(temp$Model1_class, levels = c("LM", "BLUP", "ML", "DNN"))
temp$Model2_class <- factor(temp$Model2_class, levels = c("LM", "BLUP", "ML", "DNN"))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.202225Z', start_time: '2023-07-13T19:11:02.848Z'}
temp$Model1 <- factor(temp$Model1, levels = c("LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO"))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.216463Z', start_time: '2023-07-13T19:11:02.852Z'}
fig1_ens_members <- ggplot(temp, aes(x = Models))+
    geom_tile(aes(y = Model1, fill = Model1_class))+
    geom_tile(aes(y = Model2, fill = Model2_class))+
    # Add in fake grid
    geom_vline(xintercept = 0.5+1:35, color = 'gray')+
    geom_hline(yintercept = 0.5+1:7, color = 'gray')+
    labs(x = 'Models Combinations', y = 'Models')+
    scale_fill_brewer(type = "qual", palette = "Set2")+
    theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = 'none',
          panel.grid.major = element_blank(), panel.grid.minor = element_blank())
# fig1_ens_members
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.223361Z', start_time: '2023-07-13T19:11:02.856Z'}
# layout <- "
# AAAAAAAB
# AAAAAAAB
# AAAAAAAB
# AAAAAAAB
# CCCCCCCE
# "

# options(repr.plot.width=16, repr.plot.height=10)

# (fig1_ens+fig1_orig_mods+fig1_ens_members)+plot_layout(design = layout)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.849947Z', start_time: '2023-07-13T19:11:02.861Z'}
layout <- "
A
A
A
A
B
"
options(repr.plot.width=16, repr.plot.height=10)

stacked_fig <- (fig1_ens+fig1_ens_members)+plot_layout(design = layout)
stacked_fig
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.857457Z', start_time: '2023-07-13T19:11:02.864Z'}
if(overwrite_saved_files == TRUE){
    ggsave(stacked_fig, filename = './boxplot_2mods.svg', width = 16, height = 10)
    ggsave(stacked_fig, filename = './boxplot_2mods.pdf', width = 16, height = 10)    
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.135256Z', start_time: '2023-07-13T19:11:02.869Z'}
fig1_heatmap
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.142872Z', start_time: '2023-07-13T19:11:02.873Z'}
if(overwrite_saved_files == TRUE){
    ggsave(fig1_heatmap, filename = './heatmap_2mods.svg', width = 10, height = 10)
    ggsave(fig1_heatmap, filename = './heatmap_2mods.pdf', width = 10, height = 10)
}
```

# Supplementary Figure 1

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.149441Z', start_time: '2023-07-13T19:11:02.878Z'}
# temp <- read.csv("../output/SFigure1_Data_RMSE_Ens_Reps.csv")
# temp1 <- temp
# temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.156051Z', start_time: '2023-07-13T19:11:02.883Z'}
# sfig1_ens_reps <- ggplot(temp, aes(x = n_mods, y = rmse, color = mod_group))+
#     geom_jitter(width = 0.25, height = 0.0, alpha = 0.3)+
#     geom_smooth(aes(fill = mod_group),      alpha = 0.3)+
#     theme(legend.position = 'bottom')+
#     lims(y = c(0.7, 1.2))
# # sfig1_ens_reps
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.162594Z', start_time: '2023-07-13T19:11:02.887Z'}
# temp <- read.csv("../output/SFigure1_Data_RMSE_Ens_Mods.csv")
# temp2 <- temp
# temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.169123Z', start_time: '2023-07-13T19:11:02.891Z'}
# sfig1_ens_mods <- ggplot(temp, aes(x = n_mods, y = rmse))+
#     geom_jitter(width = 0.25, height = 0.0, alpha = 0.3)+
#     geom_smooth(alpha = 0.3)+
#     lims(y = c(0.7, 1.2))
# # sfig1_ens_mods
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.175620Z', start_time: '2023-07-13T19:11:02.895Z'}
# temp <- read.csv("../output/SFigure1_Data_RMSE_Ens_SelectMods.csv")
# temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.182159Z', start_time: '2023-07-13T19:11:02.899Z'}
# sfig1_ens_selectmods <- ggplot(temp, aes(x = n_mods, y = rmse))+
#     geom_jitter(width = 0.25, height = 0.0, alpha = 0.3)+
#     geom_smooth(alpha = 0.3, color = 'red')+
#     lims(y = c(0.7, 1.2))
# # sfig1_ens_selectmods
```



```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.188693Z', start_time: '2023-07-13T19:11:02.908Z'}
# (
# (sfig1_ens_reps+geom_smooth(data = temp, alpha = 0.3, color = 'red')+lims(x = c(0, 10)))+
# (sfig1_ens_mods+geom_smooth(data = temp, alpha = 0.3, color = 'red'))+
# (sfig1_ens_selectmods)
# )
```

# Supplementary Figure 1 Redo

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.507743Z', start_time: '2023-07-13T19:11:02.914Z'}
temp <- read.csv("../output/SFigure1_Data_RMSE_Ens_SelectMods_redo.csv")


temp <- temp %>% 
    rename(model = Model1) %>% 
    mutate(model = 
        case_when(
            model == "knn" ~ "KNN",
            model == "rf" ~ "RF",
            model == "rnr" ~ "RNR",
            model == "svrl" ~ "SVR",
            model == "cat" ~ "DNN-CO",
            model == "full" ~ "DNN-SO",

            model == "lm" ~ "LM",            

            model == "bglr" ~ "BLUP",
            model == "Training Mean" ~ "Mean" )) %>% 
    rename(Model1 = model) %>% 
    rename(model = Model2) %>% 
    mutate(model = 
        case_when(
            model == "knn" ~ "KNN",
            model == "rf" ~ "RF",
            model == "rnr" ~ "RNR",
            model == "svrl" ~ "SVR",
            model == "cat" ~ "DNN-CO",
            model == "full" ~ "DNN-SO",

            model == "lm" ~ "LM",            

            model == "bglr" ~ "BLUP",
            model == "Training Mean" ~ "Mean" )) %>% 
    rename(Model2 = model)

temp$Model1 <- factor(temp$Model1, levels = c("LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO"))
temp$Model2 <- factor(temp$Model2, levels = c("LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO"))

# temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.514534Z', start_time: '2023-07-13T19:11:02.919Z'}
# temp %>% group_by(Model1, Model2, n_mods) %>% tally()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.524630Z', start_time: '2023-07-13T19:11:02.924Z'}
temp$Model1 %>% unique
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.582149Z', start_time: '2023-07-13T19:11:02.928Z'}
# duplicate to make tidy wrt model1/model2
temp2 <- temp %>% 
    rename(Model3 = Model1) %>% 
    rename(Model1 = Model2) %>% 
    rename(Model2 = Model3)
# drop where Model1==Model2; that's already in temp
temp2 <- temp2[(temp2$Model1 != temp2$Model2), ]

temp <- full_join(temp, temp2)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.619352Z', start_time: '2023-07-13T19:11:02.933Z'}
# Quick check that all groups have the same number of observations:
temp %>% 
    group_by(Model1, Model2, ensemble, n_mods) %>% 
    tally()  %>% 
    ungroup() %>% 
    select(n) %>% 
    distinct()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.632554Z', start_time: '2023-07-13T19:11:02.938Z'}
temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.798330Z', start_time: '2023-07-13T19:11:02.942Z'}
# quick vis --are trends captured by EXD and linear models?

ggplot(temp, aes(n_mods, rmse, color = Model2))+
    geom_smooth()+
    facet_grid(ensemble ~ Model1)

```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.808800Z', start_time: '2023-07-13T19:11:02.947Z'}
unique(temp$Model1)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.843007Z', start_time: '2023-07-13T19:11:02.951Z'}
# what is the rmse at n=10 for each set?

temp |> 
    filter(n_mods == 10) |> 
    group_by(ensemble, Model1, Model2, n_mods) |> 
    summarise('rmse'=mean(rmse)) |> 
    ungroup() |>
    select(-n_mods) |> 
    pivot_wider(id_cols = c('Model1', 'Model2'), values_from = 'rmse', names_from = 'ensemble') |>
    write.csv('../output/0000_possible_additional_table.csv')
```


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.850162Z', start_time: '2023-07-13T19:11:02.956Z'}
# mod1 = 'BLUP'
# mod2 = 'DNN-CO'

# dat <- temp[((temp$Model1 == mod1) & (temp$Model2 == mod2)), ]
# ggplot(dat, aes(x = n_mods, y = rmse))+
#     geom_point()


# dat$rmse <- dat$rmse * -1


# fm = drm(rmse ~ n_mods, 
#          data = dat, 
# #          fct = AR.3() # up and saturate
#          fct = EXD.3()# exponential decay
# #          fct = L.4()
# #         pmodels = list(~1, ~1)
#         )

# fm_predict <- data.frame(n_mods = seq(1, 20))
# fm_predict$rmse <- predict(fm, newdata = fm_predict)

# ggplot(dat, aes(x = n_mods, y = rmse))+
#     geom_point()+
#     geom_line(data = fm_predict, color = 'blue')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.857338Z', start_time: '2023-07-13T19:11:02.961Z'}
# target_model = 'BLUP'

# dat <- temp[((temp$Model1 == target_model) | (temp$Model2 == target_model)), ]
# dat$Comparison <- dat$Model1
# # Don't need to find special case where both are target model because this 
# # will only overwrite cases where that is not the case
# dat[dat$Model1 == target_model, 'Comparison'] <- dat[dat$Model1 == target_model, 'Model2']

# # make prediction df
# predict_df <- expand.grid(
#     rmse = NA,
#     n_mods = seq(min(dat$n_mods), max(dat$n_mods)),
#     Comparison = unique(dat$Comparison)    
# )

# fm = drm(rmse ~ n_mods, 
#          data = dat, Comparison,
#        # fct = AR.3() # up and saturate
#          fct = EXD.3(), # exponential decay
#          #  f(x) = c + (d − c)(exp(−x/e))
#          #  (c, d, e)
#          pmodels = list(
#              ~factor(Comparison), # y at t=inf
#              ~factor(Comparison), # rate
#              ~1
#          ) 
#         )


# predict_df$rmse <- predict(fm, newdata = predict_df)
# #         , se.fit = TRUE)

# # Apply grouping colors to match above
# predict_df$Comparison_class <- case_when(
#     predict_df$Comparison %in% c('LM') ~ 'LM',
#     predict_df$Comparison %in% c('BLUP') ~ 'BLUP',
#     predict_df$Comparison %in% c('KNN', 'RNR', 'RF', 'SVR') ~ 'ML',
#     predict_df$Comparison %in% c('DNN-CO', 'DNN-SO') ~ 'DNN'
#     )

# predict_df[is.na(predict_df$Comparison), 'Comparison_class'] <- predict_df[is.na(predict_df$Comparison), 'model_class']
# predict_df[is.na(predict_df$Comparison), 'Comparison'] <- predict_df[is.na(predict_df$Comparison), 'Models']

# predict_df$Comparison_class <- factor(predict_df$Comparison_class, levels = c("LM", "BLUP", "ML", "DNN"))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.864750Z', start_time: '2023-07-13T19:11:02.966Z'}
# mask_linetype1 = !(predict_df$Comparison %in% c("RF", "RNR", "SVR", "DNN-SO"))
# mask_linetype2 =  (predict_df$Comparison %in% c("RF","DNN-SO"))
# mask_linetype3 =  (predict_df$Comparison %in% c("RNR"))
# mask_linetype4 =  (predict_df$Comparison %in% c("SVR"))

# plt <- ggplot(predict_df, aes(x = n_mods, y = rmse, color  = Comparison_class, group = Comparison))+
#     geom_line(data = predict_df[mask_linetype1, ], linewidth = set_linesize, )+
#     geom_line(data = predict_df[mask_linetype2, ], linewidth = set_linesize, linetype = 'longdash')+
#     geom_line(data = predict_df[mask_linetype3, ], linewidth = set_linesize, linetype = 'dashed' )+
#     geom_line(data = predict_df[mask_linetype4, ], linewidth = set_linesize, linetype = 'dotdash')+
#     ggrepel::geom_label_repel(data =predict_df[predict_df$n_mods == max(predict_df$n_mods), ], 
#                               aes(label = Comparison, fill = Comparison_class), 
#                               color = "black", 
#                               nudge_x = length(unique(predict_df$n_mods))/40)+
#     scale_color_brewer(type = "qual", palette = "Set2")+
#     scale_fill_brewer(type = "qual", palette = "Set2")+
#     theme(legend.position = "None")+
#     labs(x = "Number of Models", y = "RMSE")   
# plt
```



```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.879037Z', start_time: '2023-07-13T19:11:02.974Z'}
# Extend to multiple 
fit_exd_for_model <- function(target_model = 'BLUP', ensemble_type = '', sd_threshold = 1e-10
){
    print(paste0("Comparing Performance: ", target_model))

    dat <- temp
    dat <- dat[(dat$ensemble == ensemble_type), ]
    dat <- dat[(dat$Model1 == target_model | dat$Model2 == target_model), ]
    dat$Comparison <- dat$Model1
    dat[dat$Model1 == target_model, 'Comparison'] <- dat[dat$Model1 == target_model, 'Model2']

    
    
#     dat <- temp[(((temp$Model1 == target_model) | (temp$Model2 == target_model)
#                 ) & (temp$ensemble == ensemble_type)), ]
#     dat$Comparison <- dat$Model1
#     # Don't need to find special case where both are target model because this 
#     # will only overwrite cases where that is not the case
#     dat[dat$Model1 == target_model, 'Comparison'] <- dat[dat$Model1 == target_model, 'Model2']

#     dat <- mutate(dat, Comparison = as.character(Comparison)) # explicitly setting comparison to chr instead of factor
    
    # allows for correct leveling if a group is dropped.

    check_sd <- dat %>% 
                group_by(Model1, Model2) %>% 
                summarise(sd = sd(rmse))


    if(nrow(check_sd[check_sd$sd <= sd_threshold, ]) == 0){
        fm = drm(rmse ~ n_mods, 
                 data = left_join(select(check_sd[check_sd$sd > sd_threshold, ], -sd), dat), 
                 Comparison,
               # fct = AR.3() # up and saturate
                 fct = EXD.3(), # exponential decay
                 #  f(x) = c + (d − c)(exp(−x/e))
                 #  (c, d, e)
                 pmodels = list(
                     ~factor(Comparison), # y at t=inf
                     ~factor(Comparison), # rate
                     ~1
                 ) 
                )

        Comparison_ok_sd <- unlist(unique(select(ungroup(left_join(select(
            check_sd[check_sd$sd > 0, ], -sd), dat)), Comparison)))

        # make prediction df
        predict_df <- expand.grid(
            rmse = NA,
            n_mods = seq(min(dat$n_mods), max(dat$n_mods)),
            Comparison = Comparison_ok_sd    
        )

        predict_df$fit <- "EXD3"

        predict_df$rmse <- predict(fm, newdata = predict_df)



    } else {
        exd_dat <- left_join(select(check_sd[check_sd$sd > sd_threshold, ], -sd), dat)
        fm = drm(rmse ~ n_mods, 
                 data = exd_dat,  
                 Comparison,
               # fct = AR.3() # up and saturate
                 fct = EXD.3(), # exponential decay
                 #  f(x) = c + (d − c)(exp(−x/e))
                 #  (c, d, e)
                 pmodels = list(
                     ~factor(Comparison), # y at t=inf
                     ~factor(Comparison), # rate
                     ~1
                 ) 
                )

        fm_linear = lm(rmse ~ n_mods, 
                       data = left_join(select(check_sd[check_sd$sd <= sd_threshold, ], -sd), dat))


        Comparison_ok_sd <- unlist(unique(select(ungroup(left_join(select(
            check_sd[check_sd$sd > sd_threshold, ], -sd), dat)), Comparison)))

        Comparison_0sd <- unlist(unique(select(ungroup(left_join(select(
            check_sd[check_sd$sd <= sd_threshold, ], -sd), dat)), Comparison)))

        # make prediction df
        predict_df <- expand.grid(
            rmse = NA,
            n_mods = seq(min(dat$n_mods), max(dat$n_mods)),
            Comparison = Comparison_ok_sd    
        )

        predict_df_0sd <- expand.grid(
            rmse = NA,
            n_mods = seq(min(dat$n_mods), max(dat$n_mods)),
            Comparison = Comparison_0sd    
        )

        predict_df$fit <- "EXD3"
        predict_df_0sd$fit <- "Linear"

        predict_df$rmse <- predict(fm, newdata = predict_df)
        predict_df_0sd$rmse <- predict(fm_linear, newdata = predict_df_0sd)

        predict_df <- rbind(predict_df, predict_df_0sd)

    }

    # Apply grouping colors to match above
    predict_df$Comparison_class <- case_when(
        predict_df$Comparison %in% c('LM') ~ 'LM',
        predict_df$Comparison %in% c('BLUP') ~ 'BLUP',
        predict_df$Comparison %in% c('KNN', 'RNR', 'RF', 'SVR') ~ 'ML',
        predict_df$Comparison %in% c('DNN-CO', 'DNN-SO') ~ 'DNN'
        )

    predict_df[is.na(predict_df$Comparison), 'Comparison_class'] <- predict_df[is.na(predict_df$Comparison), 'model_class']
    predict_df[is.na(predict_df$Comparison), 'Comparison'] <- predict_df[is.na(predict_df$Comparison), 'Models']

    predict_df$Comparison_class <- factor(predict_df$Comparison_class, levels = c("LM", "BLUP", "ML", "DNN"))

    return(list(
        predict_df = predict_df,
        fm = fm
    ))
}


plot_exd_for_model <- function(res, set_linesize = 1, set_linealpha = 0.5){
    predict_df <- res$predict_df
    
    mask_linetype1 = !(predict_df$Comparison %in% c("RF", "RNR", "SVR", "DNN-SO"))
    mask_linetype2 =  (predict_df$Comparison %in% c("RF","DNN-SO"))
    mask_linetype3 =  (predict_df$Comparison %in% c("RNR"))
    mask_linetype4 =  (predict_df$Comparison %in% c("SVR"))

    plt <- ggplot(predict_df, aes(x = n_mods, y = rmse, color  = Comparison_class, group = Comparison))+
        geom_line(data = predict_df[mask_linetype1, ], linewidth = set_linesize, alpha = set_linealpha )+
        geom_line(data = predict_df[mask_linetype2, ], linewidth = set_linesize, linetype = 'longdash', alpha = set_linealpha)+
        geom_line(data = predict_df[mask_linetype3, ], linewidth = set_linesize, linetype = 'dashed', alpha = set_linealpha )+
        geom_line(data = predict_df[mask_linetype4, ], linewidth = set_linesize, linetype = 'dotdash', alpha = set_linealpha)+
        ggrepel::geom_label_repel(data =predict_df[predict_df$n_mods == max(predict_df$n_mods), ], 
                                  aes(label = Comparison, fill = Comparison_class), 
                                  color = "black", 
                                  nudge_x = length(unique(predict_df$n_mods))/20)+
#                                   nudge_x = length(unique(predict_df$n_mods))/5)+
        scale_color_brewer(type = "qual", palette = "Set2")+
        scale_fill_brewer(type = "qual", palette = "Set2")+
        theme(legend.position = "None")+
        labs(x = "Number of Models", y = "RMSE")    
    return(plt)
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.892886Z', start_time: '2023-07-13T19:11:02.977Z'}
mod_names <- c("LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO")
ensemble_types <- c('uniform_weights', 'uniform_by_type_weights', 'inv_std_weights', 
        'inv_var_weights', 'inv_rmse_weights')

# res_list <- map(mod_names, 
#         function(e){fit_exd_for_model(target_model = e)})fit_exd_for_model(target_model = e)

# Because this takes a long time to run (est ~ 1hr) I'm splitting it up and saving out multiple data objects
# this way any debugging can be done piecemeal

# mod_names
# for(ensemble_type in ensemble_types){
#     print(paste('Trying', ensemble_type))
#     for(e in mod_names){
#         print(e)
#         fit_exd_for_model(
#             target_model = e, 
#             ensemble_type = ensemble_type,
#             sd_threshold = 1e-3)
        
#     }
# } 
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.912918Z', start_time: '2023-07-13T19:11:02.982Z'}
temp %>% head()
# FINDME I was working here trying to get the fitting to work for all models.
# why are there not all the levels of comparison seen?
# 'BLUP', 'RF', 'SVR', 'DNN-CO', 'DNN-SO'
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.919656Z', start_time: '2023-07-13T19:11:02.986Z'}
# target_model = 'LM'
# ensemble_type = 'uniform_weights'
# sd_threshold = 1e-3


# exd_dat %>% 
#     ggplot(aes(x = n_mods, y = rmse, color = Comparison))+
#     geom_point()+
#     geom_smooth()
```




















```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.932730Z', start_time: '2023-07-13T19:11:03.023Z'}
# Because this takes a long time to run (est ~ 1hr) I'm splitting it up and saving out multiple data objects
# this way any debugging can be done piecemeal

# mod_names
for(ensemble_type in ensemble_types){
    save_path <- paste0("./res_list_ENS_",ensemble_type,".RDS")

    if(!file.exists(save_path)){
        print(paste('Trying', ensemble_type))
        res_list <- map(mod_names, function(e){
            fit_exd_for_model(
                target_model = e, 
                ensemble_type = ensemble_type,
                sd_threshold = 1e-3)
        })
        saveRDS(res_list, save_path)
    }
}


```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.939512Z', start_time: '2023-07-13T19:11:03.027Z'}
# temp <- map(ensemble_types, function(ensemble_type){
#     M <- readRDS( paste0('./res_list_ENS_', ensemble_type, '.RDS') )
#     temp <- do.call(rbind, map(M, function(e){e$predict_df}))
#     temp['ensemble'] <- ensemble_type
#     return(temp)    
# })

# temp <- do.call(rbind, temp)
```


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.948053Z', start_time: '2023-07-13T19:11:03.033Z'}
mk_ensemble_composite_figure <- function(
    ensemble_type = 'uniform_weights',
    figure_y_min = 0, 
    figure_y_max = 10
){
    # Make individual two model trend plots
    res_list = readRDS( paste0("./res_list_ENS_",ensemble_type,".RDS"))

    res_plt_list <- map(res_list, function(e){
        plot_exd_for_model(res = e, set_linesize = 1, set_linealpha = 0.75)})

    # Pull in and work with ensemble using ANY models --------------------------
    if (TRUE){
        temp_all <- read.csv("../output/SFigure1_Data_RMSE_Ens_Any_n_Mods_redo.csv")

        temp_all <- temp_all[temp_all$ensemble == ensemble_type, ]
        # make prediction df
        predict_df <- expand.grid(
            n_mods = seq(min(temp_all$n_mods), max(temp_all$n_mods))
        )

        fm = drm(rmse ~ n_mods, 
                 data = temp_all, 
                 fct = EXD.3(), # exponential decay
                 #  f(x) = c + (d − c)(exp(−x/e))
                 #  (c, d, e)
                 pmodels = list(
                     ~1, # y at t=inf
                     ~1, # rate
                     ~1) )

        predict_df <- cbind(predict_df, 
                            rename(data.frame(predict(fm, 
                                                      newdata = predict_df, se.fit = TRUE)), 
                                   rmse = Prediction))

        sfig1_ens_mods_any <- ggplot(temp_all, aes(x = n_mods, y = rmse))+
            geom_point(color = 'black', alpha = 0.3)+
            geom_line(data = predict_df, color = '#ffd92f', linewidth = 1)+
            scale_x_continuous(breaks= seq(0, 80, 10))+
            labs(x = 'Number of Models', y = 'RMSE')+
            coord_cartesian(y = c(figure_y_min, figure_y_max))+
            theme(panel.grid.minor = element_blank())    
    }
    
    # Pull in and work with ensemble using all data --------------------------
    if (TRUE){
        temp_all <- read.csv("../output/SFigure1_Data_RMSE_Ens_AllMods_redo.csv")

        temp_all <- temp_all[temp_all$ensemble == ensemble_type, ]
        # make prediction df
        predict_df <- expand.grid(
            n_mods = seq(min(temp_all$n_mods), max(temp_all$n_mods))
        )

        fm = drm(rmse ~ n_mods, 
                 data = temp_all, 
                 fct = EXD.3(), # exponential decay
                 #  f(x) = c + (d − c)(exp(−x/e))
                 #  (c, d, e)
                 pmodels = list(
                     ~1, # y at t=inf
                     ~1, # rate
                     ~1) )

        predict_df <- cbind(predict_df, 
                            rename(data.frame(predict(fm, 
                                                      newdata = predict_df, se.fit = TRUE)), 
                                   rmse = Prediction))

        sfig1_ens_mods <- ggplot(temp_all, aes(x = n_mods, y = rmse))+
            geom_point(color = 'black', alpha = 0.3)+
            geom_line(data = predict_df, color = '#a6d854', linewidth = 1)+
            scale_x_continuous(breaks=c(0, 5, 10))+
            labs(x = 'Number of Models', y = 'RMSE')+
            coord_cartesian(x = c(0, 10),
                            y = c(figure_y_min, figure_y_max))+
            theme(panel.grid.minor = element_blank())    
    }
    
    
    
    
    

    # enforce matching limits
    res_plt_list <- map(res_plt_list, function(e){
        return(
            e+scale_x_continuous(breaks=c(0, 5, 10))+
            theme(panel.grid.minor = element_blank())+
            coord_cartesian(x = c(0, 10),
                            y = c(figure_y_min, figure_y_max))
    #         e+lims(y = c(min(temp$rmse), max(temp$rmse) )) 
    #         e+coord_cartesian(y = c(0.83, 1.3))+geom_hline(yintercept = 0.889879972458087) 
              )
    })

    

    multi_plt <- (
        sfig1_ens_mods_any+ggtitle(     paste0(LETTERS[1], '. ', 'Any Model'))+
           sfig1_ens_mods+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[1+1], '. ', 'Every Model'))+
        res_plt_list[[1]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[2+1], '. ', mod_names[1]))+
        res_plt_list[[2]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[3+1], '. ', mod_names[2]))+
        res_plt_list[[3]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[4+1], '. ', mod_names[3]))+
        res_plt_list[[4]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[5+1], '. ', mod_names[4]))+
        res_plt_list[[5]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[6+1], '. ', mod_names[5]))+
        res_plt_list[[6]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[7+1], '. ', mod_names[6]))+
        res_plt_list[[7]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[8+1], '. ', mod_names[7]))+
        res_plt_list[[8]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[9+1], '. ', mod_names[8])
    )+plot_layout(
        widths = c(2, 1,
                   1, 1, 1, 1, 1, 1, 1, 1)
    )
)
    return(multi_plt)
}

```


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:14.992433Z', start_time: '2023-07-13T19:11:03.041Z'}
multi_plt <- mk_ensemble_composite_figure(
    ensemble_type = 'uniform_weights',
    figure_y_min = 0.84, 
    figure_y_max = 1.15)

if(overwrite_saved_files == TRUE){
    ggsave(multi_plt, filename = './ExponentialDecay_uniform_weights.svg', width = 20, height = 10)
}
multi_plt
```


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:16.282215Z', start_time: '2023-07-13T19:11:03.047Z'}
multi_plt <- mk_ensemble_composite_figure(
    ensemble_type = 'uniform_by_type_weights',
    figure_y_min = 0.84, 
    figure_y_max = 1.15)

if(overwrite_saved_files == TRUE){
    ggsave(multi_plt, filename = './ExponentialDecay_uniform_by_type_weights.svg', width = 20, height = 10)
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:17.233341Z', start_time: '2023-07-13T19:11:03.050Z'}
multi_plt <- mk_ensemble_composite_figure(
    ensemble_type = 'inv_std_weights',
    figure_y_min = 0.84, 
    figure_y_max = 1.15)
    
if(overwrite_saved_files == TRUE){
    ggsave(multi_plt, filename = './ExponentialDecay_inv_std_weights.svg', width = 20, height = 10)
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:18.167345Z', start_time: '2023-07-13T19:11:03.056Z'}
multi_plt <- mk_ensemble_composite_figure(
    ensemble_type = 'inv_var_weights',
    figure_y_min = 0.84, 
    figure_y_max = 1.15)
    
if(overwrite_saved_files == TRUE){
    ggsave(multi_plt, filename = './ExponentialDecay_inv_var_weights.svg', width = 20, height = 10)
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:19.068240Z', start_time: '2023-07-13T19:11:03.060Z'}
multi_plt <- mk_ensemble_composite_figure(
    ensemble_type = 'inv_rmse_weights',
    figure_y_min = 0.84, 
    figure_y_max = 1.15)
    
if(overwrite_saved_files == TRUE){
    ggsave(multi_plt, filename = './ExponentialDecay_inv_rmse_weights.svg', width = 20, height = 10)
}
```



```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:21.710341Z', start_time: '2023-07-13T19:11:03.067Z'}
# make a summary table of the predicted values of each mix
mod_fit_table <- do.call(
    rbind, 
    map(ensemble_types, 
        function(ensemble_type){
            res_list = readRDS( paste0("./res_list_ENS_",ensemble_type,".RDS"))

            do.call(rbind, 
                    map(seq_along(res_list), 
                        function(i){
                            res <- res_list[[i]]
                            temp <- filter(res$predict_df, n_mods == 10)
                            temp['Model1'] <- mod_names[i]
                            temp['Ensemble'] <- ensemble_type
                            temp <- temp %>% rename(RMSE = rmse, Model2 = Comparison, Fit = fit)
                            temp <- temp[, c('Ensemble', 'Model1', 'Model2', 'Fit', 'RMSE')]
                            return(temp)    
                        }
                       )
                   )
        }
       )
)

if(overwrite_saved_files == TRUE){
    write.csv(mod_fit_table, './ExponentialDecay_fit_summary_long.csv')
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:21.725526Z', start_time: '2023-07-13T19:11:03.071Z'}
mod_fit_table_wide <- mod_fit_table %>% 
    select(-Fit) %>% 
    pivot_wider(
      names_from = Ensemble,
      values_from = RMSE
)

if(overwrite_saved_files == TRUE){
    write.csv(mod_fit_table_wide, './ExponentialDecay_fit_summary_wide.csv')
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:21.736622Z', start_time: '2023-07-13T19:11:03.076Z'}
ensemble_types
mod_names
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:21.750024Z', start_time: '2023-07-13T19:11:03.079Z'}
mod_fit_table %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:21.758713Z', start_time: '2023-07-13T19:11:03.083Z'}
# mod_fit_table %>% 
#     ggplot(aes(x = Ensemble, y = RMSE, group = Model1))+
#     geom_line()+
#     facet_grid(Model2~.)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:21.765240Z', start_time: '2023-07-13T19:11:03.087Z'}
# mod_fit_table_wide %>% 
#     pivot_longer(
#     cols = c('uniform_by_type_weights', 'inv_std_weights', 'inv_var_weights', 'inv_rmse_weights')) %>% 
#     rename(Ensemble = name, RMSE = value) %>% 
#     ggplot(aes(x = uniform_weights, y = RMSE, color = Ensemble))+
#         geom_smooth(method = 'lm', se = F, alpha = 0.5)+
#         geom_point()+
#         coord_fixed()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:21.771604Z', start_time: '2023-07-13T19:11:03.091Z'}
# mod_fit_table_wide |> head()
```

# Understanding Performance

## Load Data

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.039035Z', start_time: '2023-07-13T19:11:03.098Z'}
ModTrain <- read.csv('../output/01_mod_train.csv') %>% select(-'X')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.242124Z', start_time: '2023-07-13T19:11:03.102Z'}
ModTest <- read.csv('../output/01_mod_test.csv') %>% select(-'X')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.259471Z', start_time: '2023-07-13T19:11:03.108Z'}
ModWeights <- read.csv('../output/01_mod_weights.csv') %>% select(-'X')
ModWeights  %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.276656Z', start_time: '2023-07-13T19:11:03.114Z'}
ModWeightsTest <- read.csv('../output/01_mod_weights_test.csv') %>% select(-'X')
ModWeightsTest  %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.445877Z', start_time: '2023-07-13T19:11:03.119Z'}
# Allow for easy renaming of columns from (e.g.) bglr_0 to BLUP_0

replacement_names <- data.frame(all_mod_cols = names(ModTrain)) |> 
    mutate(model = str_remove(all_mod_cols, '_\\d' )) |> 
    mutate(model_num = str_remove(all_mod_cols, '\\D+_' )) |> 
    standardize_dat() |>
    mutate(model_num = paste0(model, '_', model_num)) |>
    select(all_mod_cols, model_num) |>
    filter(!(all_mod_cols %in% c(
    'Pedigree',
    'F',
    'M',
    'ExperimentCode',
    'Year',
    'y' 
    ))) |>
    rename(old_name = all_mod_cols, new_name = model_num)

replacement_names |> head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.462210Z', start_time: '2023-07-13T19:11:03.123Z'}
# update names
names(ModTrain) <- map(names(ModTrain), function(e){
    out <- e
    if(e %in% replacement_names$old_name){out <- replacement_names[replacement_names$old_name == e, 'new_name']}
    return(out) })

names(ModTest) <- map(names(ModTest), function(e){
    out <- e
    if(e %in% replacement_names$old_name){out <- replacement_names[replacement_names$old_name == e, 'new_name']}
    return(out) })
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.483281Z', start_time: '2023-07-13T19:11:03.127Z'}
ModWeights <- ModWeights |> 
    mutate(model = str_remove(all_mod_cols, '_\\d' )) |> 
    mutate(model_num = str_remove(all_mod_cols, '\\D+_' )) |> 
    standardize_dat() |>
    mutate(model_num = paste0(model, '_', model_num))
ModWeights |> head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.495567Z', start_time: '2023-07-13T19:11:03.132Z'}
ModWeightsTest <- ModWeightsTest |> 
    mutate(model = str_remove(all_mod_cols, '_\\d' )) |> 
    mutate(model_num = str_remove(all_mod_cols, '\\D+_' )) |> 
    standardize_dat() |>
    mutate(model_num = paste0(model, '_', model_num))
```

## Plot Model Weights

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.502788Z', start_time: '2023-07-13T19:11:03.138Z'}
# # Directly compare values in train and test


# do.call(rbind, list(
#     mutate(ModWeights, Split = 'Train'),
#     mutate(ModWeightsTest, Split = 'Test') )) |> 
#     select(inv_rmse_weights, inv_var_weights, inv_std_weights, model_num, model, Split) |>
#     pivot_wider(names_from = Split, values_from = c('inv_rmse_weights', 
#                                                     'inv_var_weights',
#                                                     'inv_std_weights')) |>
#     group_by(model) |>
#     summarise(inv_rmse_weights_Train = median(inv_rmse_weights_Train),
#               inv_rmse_weights_Test = median(inv_rmse_weights_Test),
#               inv_var_weights_Train = median(inv_var_weights_Train),
#               inv_var_weights_Test = median(inv_var_weights_Test),
#               inv_std_weights_Train = median(inv_std_weights_Train),
#               inv_std_weights_Test = median(inv_std_weights_Test)  ) |> 
#     ungroup() |>
#     ggplot()+
#         geom_segment(aes(x = model, xend = model, y = inv_rmse_weights_Train, yend = inv_var_weights_Test), 
#                      arrow = arrow(length = unit(0.01, "npc")), 
#                      position = position_nudge(x = -0.1))+
#         geom_segment(aes(x = model, xend = model, y = inv_var_weights_Train, yend = inv_var_weights_Test), 
#                      arrow = arrow(length = unit(0.01, "npc")), color = 'red', 
#                      position = position_nudge(x = 0.1))+
#         geom_segment(aes(x = model, xend = model, y = inv_std_weights_Train, yend = inv_var_weights_Test), 
#                      arrow = arrow(length = unit(0.01, "npc")), color = 'orange', 
#                      position = position_nudge(x = 0.0))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.509944Z', start_time: '2023-07-13T19:11:03.142Z'}
# # Directly compare values in train and test
# ModWeight_Pr_TrainTest <-do.call(rbind, list(
#     mutate(ModWeights, Split = 'Train'),
#     mutate(ModWeightsTest, Split = 'Test') )) |> 
#     select(inv_rmse_weights, inv_var_weights, inv_std_weights, model_num, model, Split) |>
#     pivot_wider(names_from = Split, values_from = c('inv_rmse_weights', 
#                                                     'inv_var_weights',
#                                                     'inv_std_weights')) |>
#     group_by(model) |>
#     summarise(inv_rmse_weights_Train = median(inv_rmse_weights_Train),
#               inv_rmse_weights_Test = median(inv_rmse_weights_Test),
#               inv_var_weights_Train = median(inv_var_weights_Train),
#               inv_var_weights_Test = median(inv_var_weights_Test),
#               inv_std_weights_Train = median(inv_std_weights_Train),
#               inv_std_weights_Test = median(inv_std_weights_Test)  ) |> 
#     ungroup() |>
#     # standardize to sum to 1
#     mutate(inv_rmse_weights_Train = inv_rmse_weights_Train/sum(inv_rmse_weights_Train),
#            inv_rmse_weights_Test = inv_rmse_weights_Test/sum(inv_rmse_weights_Test),
#            inv_var_weights_Train = inv_var_weights_Train/sum(inv_var_weights_Train),
#            inv_var_weights_Test = inv_var_weights_Test/sum(inv_var_weights_Test),
#            inv_std_weights_Train = inv_std_weights_Train/sum(inv_std_weights_Train),
#            inv_std_weights_Test = inv_std_weights_Test/sum(inv_std_weights_Test)) 

# ModWeight_Pr_TrainTest |>
#     ggplot()+
#         geom_segment(aes(x = model, xend = model, y = inv_rmse_weights_Train, yend = inv_var_weights_Test), 
#                      arrow = arrow(length = unit(0.01, "npc")), color = '#2ca25f', 
#                      position = position_nudge(x = -0.1), size = 2)+
#         geom_segment(aes(x = model, xend = model, y = inv_var_weights_Train, yend = inv_var_weights_Test), 
#                      arrow = arrow(length = unit(0.01, "npc")), color = '#3182bd', 
#                      position = position_nudge(x = 0.1), size = 2)+
#         geom_segment(aes(x = model, xend = model, y = inv_std_weights_Train, yend = inv_var_weights_Test), 
#                      arrow = arrow(length = unit(0.01, "npc")), color = '#9ecae1', 
#                      position = position_nudge(x = 0.0), size = 2)

```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.516977Z', start_time: '2023-07-13T19:11:03.145Z'}
# ModWeight_Pr_TrainTest |>
#     mutate(inv_rmse_weights_Train = inv_rmse_weights_Train - inv_var_weights_Test,
# #               inv_rmse_weights_Test = inv_rmse_weights_Test - inv_var_weights_Test,
#               inv_var_weights_Train = inv_var_weights_Train - inv_var_weights_Test,
#               inv_var_weights_Test = inv_var_weights_Test - inv_var_weights_Test,
#               inv_std_weights_Train = inv_std_weights_Train - inv_var_weights_Test,
# #               inv_std_weights_Test = inv_std_weights_Test - inv_var_weights_Test 
#           ) |>
#     select(-inv_var_weights_Test) |>
#     pivot_longer(cols = c('inv_rmse_weights_Train',
# #                           'inv_rmse_weights_Test',
#                           'inv_var_weights_Train', 
#                           'inv_std_weights_Train', 
# #                           'inv_std_weights_Test'
#                          )) |>
#     mutate(value = abs(value)) |>
#     ggplot(aes(value, name, fill = name))+
#         ggdist::stat_halfeye(
#             adjust = .5,
#             width = .6, 
#             .width = c(.5, .95) # slab interval == IQR and 95%
#         ) + 
# #         geom_point(position = position_nudge(y = -.15))+
#         ggdist::stat_dots(
#             side = "left", 
#             dotsize = 1.91,
#             justification = 1.05, 
#             binwidth = .001
#           )+
#     scale_fill_manual(values = c('#2ca25f',
#                                 '#9ecae1',
#                                  '#3182bd'))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.523473Z', start_time: '2023-07-13T19:11:03.149Z'}
# install.packages('ggdist')
# library(ggdist)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.530004Z', start_time: '2023-07-13T19:11:03.153Z'}
# ggplot(data.frame(x = seq(0.1, 1, length.out = 100), 
#                   y = 1/sqrt(seq(0.1, 1, length.out = 100))), aes(x, y))+
#     geom_point()+
#     geom_abline(slope = 1, intercept = 0)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.536487Z', start_time: '2023-07-13T19:11:03.157Z'}
# ggplot()+
#     geom_density(aes(x = ModTrain$y), fill = 'black', alpha = 0.3)+
#     geom_density(aes(x = ModTest$y), fill = 'blue', alpha = 0.3)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.542999Z', start_time: '2023-07-13T19:11:03.161Z'}
# library(corrr)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.550461Z', start_time: '2023-07-13T19:11:03.165Z'}
# # do.call(rbind, list(
# #     mutate(ModWeights, Split = 'Train'),

# full_join(
#     pivot_longer(mutate(ModWeights, Split = 'Train'), 
#                  cols = c('uniform_weights', 
#                             'uniform_by_type_weights', 
#                             'inv_rmse_weights', 
#                             'inv_var_weights',
#                             'inv_std_weights')),

#         pivot_longer(mutate(ModWeightsTest, Split = 'Test'), 
#                  cols = c(
#                     'uniform_weights', 
#                     'uniform_by_type_weights', 
#                     'inv_rmse_weights', 
#                     'inv_var_weights',
#                     'inv_std_weights'
#                          ))
# ) |> 
#     group_by(Split, model_num, name) |>
#     # standardize so that weights sum to 1
#     summarise(value = median(value)) |>
#     mutate(pr_value = value/sum(value)) |>
#     select(-value) |>
#     ungroup() |>
#     pivot_wider(id_cols = c('model_num'), 
#             names_from = c('Split', 'name'), 
#             values_from = 'pr_value') |>
#     select(-model_num) |>
#     correlate() |>


#     pivot_longer(cols = c(
#         'Test_inv_rmse_weights',
#         'Test_inv_std_weights',
#         'Test_inv_var_weights',
#         'Test_uniform_by_type_weights',
#         'Test_uniform_weights',
#         'Train_inv_rmse_weights',
#         'Train_inv_std_weights',
#         'Train_inv_var_weights',
#         'Train_uniform_by_type_weights',
#         'Train_uniform_weights',
#     )) |>
#     rename(MedianWeights1 = term,
#            MedianWeights2 = name) |>
#     ggplot(aes(MedianWeights1, MedianWeights2, fill = value))+
#         geom_tile()+
#         geom_text(aes(label = round(value, digits = 3)), color = 'white')+
#         scale_fill_viridis_c()+
#         coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")+
#         theme(axis.text.x = element_text(angle = 90, hjust = 1))+
#         geom_hline(yintercept = add_lines_at, color = 'white')+
#         geom_vline(xintercept = add_lines_at, color = 'white')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.557300Z', start_time: '2023-07-13T19:11:03.169Z'}
# y_lim = 5

# rbind(mutate(ModTrain, Split = 'Train'),
#       mutate(ModTest, Split = 'Test')) |>
#     select(-c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year')) |>
#     pivot_longer(cols = c(names(select(ModTrain, -c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year'))))) |>
#     mutate(name = str_remove(name, pattern = '_\\d')) |>
#     mutate(Split = factor(Split, levels = c('Train', 'Test'))) |>
#     ggplot(aes(name, value, fill = Split))+
#             geom_boxplot()+
#             coord_cartesian(ylim = c(-y_lim, y_lim))+
#             scale_fill_manual(values = c('White', 'LightGray'))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.563982Z', start_time: '2023-07-13T19:11:03.173Z'}
# ModTest |> 
#     select(-c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year')) |> 
#     correlate() |>
# #     shave() |>
#     pivot_longer(cols = names(select(ModTest, -c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year')))) |>
#     mutate(name2 = str_remove(name, pattern = '_\\d'),
#            term2 = str_remove(term, pattern = '_\\d')) |>
#     group_by(name2, term2) |>
#     summarize(value = median(value, na.rm = T))
    
```

## Prediciton Correlations

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.621046Z', start_time: '2023-07-13T19:11:03.179Z'}
# # install.packages('corrplot')
# library('corrplot')

# ModTest |> select(-c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year')) |> cor() |> corrplot()

# # install.packages('corrr')
# library(corrr)

# ModTest |> 
#     select(-c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year')) |> 
#     correlate() |> 
#     pivot_longer(cols = names(select(ModTest, -c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year')))
#                 ) |> 
#     ggplot(aes(term, name, fill = value))+
#     geom_tile()+
#     scale_fill_viridis_c()+
#     coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")+
#     theme(axis.text.x = element_text(angle = 90, hjust = 1))+
#     geom_hline(yintercept = add_lines_at, color = 'white')+
#     geom_vline(xintercept = add_lines_at, color = 'white')



# ModTest |> 
#     select(-c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year')) |> 
#     correlate() |>
# #     shave() |>
#     pivot_longer(cols = names(select(ModTest, -c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year')))) |>
#     mutate(name2 = str_remove(name, pattern = '_\\d'),
#            term2 = str_remove(term, pattern = '_\\d')) |>
#     group_by(name2, term2) |>
#     summarize(value = median(value, na.rm = T)) |>
#     ggplot(aes(term2, name2, fill = value))+
#     geom_tile()+
#     geom_text(aes(label = round(value, digits = 3)), color = 'white')+
#     scale_fill_viridis_c()+
#     coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")+
#     theme(axis.text.x = element_text(angle = 90, hjust = 1))+
#     geom_hline(yintercept = add_lines_at, color = 'white')+
#     geom_vline(xintercept = add_lines_at, color = 'white')
    
    

# plt <- ModTest |> 
#     mutate(rBLUP_0 = y - BLUP_0,
#            rLM_0 = y - LM_0) |>
#     mutate(diff = rBLUP_0 + rLM_0) |>
#     ggplot(aes(rBLUP_0, rLM_0, color = diff))+
#         geom_point()+
#         geom_point(color = 'black', shape = 1, alpha = 0.3
#                   )+
#         scale_color_distiller(type = 'div')+
#         coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")

# plt
# # install.packages('ggExtra')
# # library(ggExtra)
# # ggMarginal(plt)



# ModTest |> 
#     mutate(rBLUP_0 = y - BLUP_0,
#            `rDNN-CO_0` = y - `DNN-CO_0`) |>
#     ggplot(aes(rBLUP_0, `rDNN-CO_0`))+
#         geom_point()

# ModTest |> 
#     ggplot(aes(BLUP_0, `DNN-CO_0`))+
#         geom_point()

# ModTest |> 
#     mutate(rBLUP_0 = y - BLUP_0,
#            rRF_0 = y - RF_0) |>
#     ggplot(aes(rBLUP_0, rRF_0))+
#         geom_point()

# ModTest |> 
#     ggplot(aes(BLUP_0, `RF_0`))+
#         geom_point()

# ModTest |> 
#     ggplot(aes(BLUP_0, `RF_0`))+
#         geom_point()

```

### Where are the errors when BLUPs do well?

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.628123Z', start_time: '2023-07-13T19:11:03.185Z'}
# ModTestErrors <- ModTest |> 
#     pivot_longer(cols = names(select(ModTest, -c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year', 'y')))) |>
#     mutate(ModelGroup = str_remove(name, '_\\d')) |>
#     group_by(ModelGroup, Pedigree, F, M, ExperimentCode, Year, y) |>
#     summarize(value = mean(value)) |> 
#     distinct() |>
#     ungroup() |>
#     rename(yhat = value) |>
#     mutate(Error = y - yhat) |>
#     mutate(AbsError = abs(Error)) |>
#     pivot_wider(names_from = ModelGroup, values_from = c('yhat', 'Error', 'AbsError'))
# head(ModTestErrors)    
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.634640Z', start_time: '2023-07-13T19:11:03.190Z'}
# ModTestErrors |> ggplot(aes(AbsError_BLUP))+geom_density()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.641232Z', start_time: '2023-07-13T19:11:03.194Z'}
# # To look at the GxE explained by each model maybe we can look at the incidence of each site 
# # or each GxE combination for the most extreme absolute errors. We would predict that the model(s)
# # that handle GxE best would have the most even distribution.


# error_col = 'AbsError_BLUP'

# mask = (ModTestErrors[[error_col]] >= quantile(ModTestErrors[[error_col]], 0.75))

# ModTestErrors[mask, ]
```

## Prediciton PCA

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.647675Z', start_time: '2023-07-13T19:11:03.199Z'}
# install.packages('factoextra')
# install.packages("FactoMineR") #PCA
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.654155Z', start_time: '2023-07-13T19:11:03.204Z'}
# library(factoextra)
# # library(missMDA) # for imputePCA 
# library("FactoMineR") #PCA
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.660607Z', start_time: '2023-07-13T19:11:03.208Z'}
# ResPCA <- PCA(select(ModTrain, -c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year')), scale.unit = T)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.667037Z', start_time: '2023-07-13T19:11:03.212Z'}
# fviz_screeplot(ResPCA, addlabels = T)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.673524Z', start_time: '2023-07-13T19:11:03.216Z'}
# fviz_pca_var(ResPCA, 
#              col.var = "contrib",
#              gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#              repel = TRUE # Avoid text overlapping
#              )
```


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.680043Z', start_time: '2023-07-13T19:11:03.222Z'}
# ResPCA <- PCA(select(ModTest, -c('Pedigree', 'F', 'M', 'ExperimentCode', 'Year')), scale.unit = T)
# # get_eig(ResPCA)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.686424Z', start_time: '2023-07-13T19:11:03.225Z'}
# fviz_screeplot(ResPCA, addlabels = T)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.693011Z', start_time: '2023-07-13T19:11:03.230Z'}
# # fviz_pca_biplot(ResPCA, repel = T)

# fviz_pca_var(ResPCA, 
#              col.var = "contrib",
#              gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#              repel = TRUE # Avoid text overlapping
#              )
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.699551Z', start_time: '2023-07-13T19:11:03.235Z'}
# fviz_pca_var(ResPCA, 
#              col.var = "contrib",
#              gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
#              repel = TRUE # Avoid text overlapping
#              )
```

## Are the distributions of y very different? 

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.706031Z', start_time: '2023-07-13T19:11:03.243Z'}
# ggplot()+
#     geom_density(aes(x = ModTrain$y))+
#     geom_density(aes(x = ModTest$y), color = 'red')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.712518Z', start_time: '2023-07-13T19:11:03.248Z'}
# okay so if test y is greater... are there methods that do particuarly poorly on 
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.719152Z', start_time: '2023-07-13T19:11:03.252Z'}
# ggplot()+
#     geom_density(aes(x = ModTrain$y- ModTrain$bglr_0))+
#     geom_density(aes(x = ModTrain$y- ModTrain$bglr_1))+
#     geom_density(aes(x = ModTest$y- ModTest$bglr_0), color = 'red')+
#     geom_density(aes(x = ModTest$y- ModTest$bglr_1), color = 'red')+
#     geom_density(aes(x = ModTest$y- ModTest$bglr_2), color = 'red')+
#     geom_density(aes(x = ModTest$y- ModTest$bglr_3), color = 'red')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.725832Z', start_time: '2023-07-13T19:11:03.256Z'}
# ggplot()+
#     geom_density(aes(x = ModTrain$y- ModTrain$cat_0))+
#     geom_density(aes(x = ModTest$y- ModTest$cat_0), color = 'red')

# ggplot()+
#     geom_density(aes(x = ModTrain$y- ModTrain$lm_0))+
#     geom_density(aes(x = ModTest$y- ModTest$lm_0), color = 'red')



# ggplot()+
#     geom_density(aes(x = ModTrain$y- ModTrain$rf_0))+
#     geom_density(aes(x = ModTest$y- ModTest$rf_0), color = 'red')

```

## Variance Component Analysis


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.732406Z', start_time: '2023-07-13T19:11:03.264Z'}
# ModTest %>% 
#     ggplot(aes(x = M, y = y))+
#         geom_boxplot()
# #         facet_wrap(.~interaction(ExperimentCode, Year))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.980416Z', start_time: '2023-07-13T19:11:03.269Z'}
# install.packages('VCA')
# library(VCA)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.987843Z', start_time: '2023-07-13T19:11:03.273Z'}
# # install.packages('palmerpenguins')
# library(palmerpenguins)
# penguins <- as.data.frame(penguins)
# penguins  %>% head

# # base / ... / top
# varPlot(form=bill_length_mm~species/sex/island, 
#         Data=drop_na(penguins),
#         MeanLine=list(var=c("species", "sex",  "island"), 
#                       col=c("magenta", "blue", "green"), lwd=c(2,2,2)), 
#         BG=list(var="island", col=paste0("gray", c(70,80,90)))
       
#        )
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:25.030571Z', start_time: '2023-07-13T19:11:03.278Z'}
ModAllPlt <- rbind(mutate(ModTrain, Set = 'Train'), 
                mutate(ModTest, Set = 'Test')) |>
        select(Pedigree, ExperimentCode, Year, Set, y) |>
        unite(SiteYear, ExperimentCode:Year)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:25.057928Z', start_time: '2023-07-13T19:11:03.282Z'}
# ModAllPlt
# ModAllPlt |> filter(Set == 'Train') |> select(SiteYear) |> distinct() |> unlist()

# only for ease of plot ordering later.
first.SiteYears <- ModAllPlt %>% filter(Set == 'Train')  %>% select(SiteYear)  %>% distinct()  %>% unlist()  %>% sort()
last.SiteYears <- ModAllPlt %>% filter(Set == 'Test')  %>% select(SiteYear)  %>% distinct()  %>% unlist()  %>% sort()


ModAllPlt$Set <- as.factor(ModAllPlt$Set)
ModAllPlt$SiteYear <- factor(ModAllPlt$SiteYear, levels = c(first.SiteYears, last.SiteYears))
ModAllPlt$Pedigree <- as.factor(ModAllPlt$Pedigree)
```


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:25.064889Z', start_time: '2023-07-13T19:11:03.289Z'}

# sort(aa)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:34.796739Z', start_time: '2023-07-13T19:11:03.294Z'}
outPlt <-varPlot(form=y~Set/SiteYear/Pedigree, Data=ModAllPlt, 
       MeanLine=list(var=c("ExperimentCode", "Set"), 
                      col=c("cyan", "magenta"), lwd=c(2))
       )
head(outPlt)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:34.814390Z', start_time: '2023-07-13T19:11:03.299Z'}
outPlt <- outPlt |> arrange(desc(Set), SiteYear, Pedigree) |> select(-Xcoord)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:34.850311Z', start_time: '2023-07-13T19:11:03.304Z'}
outPltXcoord <- distinct(outPlt[, c('Pedigree', 'SiteYear')])
outPltXcoord$Xcoord <- seq(1, nrow(outPltXcoord))
outPlt <- full_join(outPlt, outPltXcoord)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:35.406506Z', start_time: '2023-07-13T19:11:03.309Z'}
outPlt |> head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.461460Z', start_time: '2023-07-13T19:11:03.314Z'}
# Alternative to point plot: Sd bars

outPlt.pos.sd.siteyeargeno <- outPlt |> 
    as.tibble() |> 
    group_by(SiteYear, Pedigree) |> 
    summarise(
        x = min(Xcoord),
        ymeanPsd = mean(y)+(0.5*sd(y)),
        ymeanMsd = mean(y)-(0.5*sd(y)),
        ymean = mean(y)
    ) |> ungroup()

outPlt.pos.sd.siteyeargeno %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.477432Z', start_time: '2023-07-13T19:11:03.320Z'}
outPlt.pos.lables.SiteYear <- outPlt |> 
    group_by(SiteYear) |>
    summarise(xMin = min(Xcoord),
              xMax = max(Xcoord),
              xMean = mean(Xcoord)
             ) |> ungroup()

outPlt.pos.lables.Set <- outPlt |> 
    group_by(Set) |>
    summarise(xMin = min(Xcoord),
              xMax = max(Xcoord),
              xMean = mean(Xcoord)
             ) |> ungroup()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.489163Z', start_time: '2023-07-13T19:11:03.324Z'}
outPlt.pos.lables.Set
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.501365Z', start_time: '2023-07-13T19:11:03.328Z'}
outPlt.pos.train <- outPlt |> filter(Set == 'Train') |> summarise(
    x = min(Xcoord),
    xend = max(Xcoord),
    xmean = mean(Xcoord)
)

outPlt.pos.test <- outPlt |> filter(Set == 'Test') |> summarise(
    x = min(Xcoord),
    xend = max(Xcoord),
    xmean = mean(Xcoord)
)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.529740Z', start_time: '2023-07-13T19:11:03.333Z'}
outPlt.pos.meanlines.siteyear <- outPlt |> 
    as.tibble() |> 
    group_by(Set, SiteYear) |> 
    summarise(
        x = min(Xcoord),
        xend = max(Xcoord),
        xmean = mean(Xcoord),
        ymean = mean(y)
    ) |> ungroup()
```



```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.581957Z', start_time: '2023-07-13T19:11:03.340Z'}
outPlt.pos.meanlines.site <- outPlt |> 
    mutate(Site = as.character(SiteYear)) |> 
    mutate(Site = str_remove(Site, pattern = "_\\d+")) |> 
    as.tibble() |> 
    mutate(Set = as.character(Set)) |>
    group_by(Set, Site) |> 
    summarise(
        x = min(Xcoord),
        xend = max(Xcoord),
        xmean = mean(Xcoord),
        ymean = mean(y)
    ) |> ungroup()

outPlt.pos.meanlines.site %>% head()
```


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.607555Z', start_time: '2023-07-13T19:11:03.347Z'}
# for vertical lines between site mean and siteyear mean


# outPlt.pos.vlines.sitesiteyear <- full_join(
#     (outPlt.pos.meanlines.siteyear |> 
#      mutate(
#          SiteYear = as.character(SiteYear),
#          Site = as.character(SiteYear)) |> 
#     mutate(Site = str_remove(Site, pattern = "_\\d+"))),

#     (rename(outPlt.pos.meanlines.site, 
# #           x.site = x,
# #           xend.site = xend,
# #           xmean.site = xmean,
#           ymean.site = ymean) |> 
#      select(Site, ymean.site))
#     )
# # outPlt.pos.vlines.sitesiteyear %>% tail()
# outPlt.pos.vlines.sitesiteyear |> filter(Site == "IAH3")



t1 <- (outPlt.pos.meanlines.siteyear |> 
     mutate(
         SiteYear = as.character(SiteYear),
         Site = as.character(SiteYear)) |> 
    mutate(Site = str_remove(Site, pattern = "_\\d+")))
# filter(Site == "IAH3")

# t1 |> filter(SiteYear == "IAH3_2014")

t2 <- (rename(outPlt.pos.meanlines.site,
          ymean.site = ymean) |> 
     select(Set, Site, ymean.site))
# t2 |> filter(Site == "IAH3")

outPlt.pos.vlines.sitesiteyear <- full_join(t1, t2) 
# outPlt.pos.vlines.sitesiteyear |> filter(Site == "IAH3")
```


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.621063Z', start_time: '2023-07-13T19:11:03.353Z'}
outPlt.pos.meanlines.site %>% head()
```


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:37.683778Z', start_time: '2023-07-13T19:11:03.359Z'}
bar.pos.y = -4.25 # y max is 4.09466474615452
bar.pos.siteyear = -3 # y min is -2.89449085652765

variability_chart <- ggplot()+
    # Train / Test -----------------------------------------------------------
    geom_segment(data = outPlt.pos.train, aes(x = xend, xend = xend, y = bar.pos.y, yend = 4), color = 'black')+
    # hlines/labels
#     geom_segment(data = outPlt.pos.train, aes(x = x, xend = xend, y = bar.pos.y, yend = bar.pos.y), color = 'blue')+
    geom_label(data = outPlt.pos.train, aes(x = xmean, y = bar.pos.y, label = 'Train'))+
#     geom_segment(data = outPlt.pos.test, aes(x = x, xend = xend, y = bar.pos.y, yend = bar.pos.y), color = 'red')+
    geom_label(data = outPlt.pos.test, aes(x = xmean, y = bar.pos.y, label = 'Test'))+

    # Observations -----------------------------------------------------------
    geom_point(data = outPlt, aes(Xcoord, y), size = 0.1, color = 'gray')+ # raw values
#     geom_point(data = outPlt.pos.sd.siteyeargeno,
#                aes(x, ymean), size = 0.1, color = 'gray')+
#     geom_segment(data = outPlt.pos.sd.siteyeargeno[!is.na(outPlt.pos.sd.siteyeargeno$ymeanPsd), ],
#                aes(x=x, xend=x, y=ymeanMsd, yend=ymeanPsd), size = 0.1, color = 'gray')+

    # Residual Env to SiteYear ---------------------------------------------------
    geom_segment(data = outPlt.pos.vlines.sitesiteyear , 
                 aes(x = xmean, xend = xmean, y = ymean, yend = ymean.site), color = 'cornflowerblue', size = 1)+
    # SiteYear Means --------------------------------------------------------------
    geom_segment(data = outPlt.pos.meanlines.siteyear, aes(x = x, xend = xend, y = ymean, yend = ymean), color = 'red', size = 1)+
    # Site Means -------------------------------------------------------------
    geom_segment(data = outPlt.pos.meanlines.site , aes(x = x, xend = xend, y = ymean, yend = ymean), color = 'red', size = 1)+
    # x "axis"
    geom_text(data = outPlt.pos.meanlines.siteyear, aes(x = xmean, y = bar.pos.siteyear, label = SiteYear), angle = 90, hjust = 1)+
    labs(y = 'Normalize Yield')+    
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.major.y = element_line(colour = 'darkgray'),
          panel.grid.minor.x = element_blank(),
          panel.grid.minor.y = element_line(colour = 'darkgray')
         )+
    coord_cartesian(ylim = c(bar.pos.y, 4))
    
variability_chart
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:37.832266Z', start_time: '2023-07-13T19:11:03.364Z'}
outPltAnnotated <- outPlt |> 
    mutate(Site = as.character(SiteYear)) |> 
    mutate(Site = str_remove(Site, pattern = "_\\d+")) |>
    group_by(Set, Site) |>
    mutate(yMeanSite = mean(y)) |>
    ungroup() |>
    group_by(Set, SiteYear) |>
    mutate(yMeanSiteYear = mean(y)) |>
    ungroup() 

# Figure out x position for
## points
outPltAnnotated <- outPltAnnotated |>
    mutate(Set = factor(Set, levels = c('Train', 'Test'))) |>
    group_by(Set) |>
    arrange(Set, yMeanSite, SiteYear, Pedigree) |>
    ungroup()

outPltAnnotated$Xcoord <- 1:nrow(outPltAnnotated)

## group stats
outPltAnnotated <- outPltAnnotated |>
    group_by(Set) |>
    mutate(xMinSet= min(Xcoord),
           xMeanSet =mean(Xcoord),
           xMaxSet= max(Xcoord)) |>
    ungroup() |>
    group_by(Set, Site) |>
    mutate(xMinSite = min(Xcoord),
           xMeanSite =mean(Xcoord),
           xMaxSite = max(Xcoord)) |>
    ungroup() |>
    group_by(Set, SiteYear) |>
    mutate(xMinSiteYear = min(Xcoord),
           xMeanSiteYear =mean(Xcoord),
           xMaxSiteYear = max(Xcoord)) |>
    ungroup() 

## Move Pedigree's to the same Xcoord
outPltAnnotated <- outPltAnnotated |>
    group_by(Set, SiteYear, Pedigree) |>
    mutate(Xcoord = min(Xcoord)) |>
    ungroup() 


outPltAnnotated %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:37.838991Z', start_time: '2023-07-13T19:11:03.369Z'}
# # get year sep
# outPltAnnotated <- outPlt |> 
#     mutate(Site = as.character(SiteYear)) |> 
#     mutate(Site = str_remove(Site, pattern = "_\\d+"))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:37.858809Z', start_time: '2023-07-13T19:11:03.373Z'}
# Deduplicated versions to prevent drawing multiple identical objects
outPltAnnotated.Set <- outPltAnnotated |> select(ends_with('Set')) |> distinct()
outPltAnnotated.Site <- outPltAnnotated |> select(ends_with('Site')) |> distinct()
outPltAnnotated.SiteYear <- outPltAnnotated |> select(ends_with('Year')) |> distinct()

# add in year only col
outPltAnnotated.SiteYear <- outPltAnnotated.SiteYear |> 
    mutate(Year = as.character(SiteYear)) |> 
    mutate(Year = str_remove(Year, pattern = '^.*_'))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:37.867176Z', start_time: '2023-07-13T19:11:03.377Z'}


# to alternate colors on labels
outPltAnnotated.Site$everyOtherSite <- rep(c('a', 'b'), times = ceiling(nrow(outPltAnnotated.Site)/2))[1:nrow(outPltAnnotated.Site)]

```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:45.405845Z', start_time: '2023-07-13T19:11:03.381Z'}

# rasterized for easier post processing in inkscape 
use_dpi = 300

variability_chart <- ggplot(outPltAnnotated)+
    # Train / Test -----------------------------------------------------------
    geom_segment(data = outPltAnnotated.Set, aes(x = xMinSet, xend = xMaxSet, y = 4.1+.1, yend = 4.1+.1, color = Set), size = 1)+
    geom_segment(data = outPltAnnotated.Set, aes(x = xMinSet, xend = xMaxSet, y = -3, yend = -3, color = Set), size = 1)+
    geom_label(data = outPltAnnotated.Set, aes(x = xMeanSet, y = 4.1+.1, label = Set))+
    # x "axis"
#     geom_text(aes(x = xMeanSiteYear, y = -3, label = SiteYear), angle = 90, hjust = 1, size = 2.5)+ # SiteYear
    geom_text(data=outPltAnnotated.Site, aes(x = xMeanSite, y = -3.5, label = Site), angle = 90, hjust = 1, size = 2.5)+
    geom_segment(data = outPltAnnotated.Site, aes(x = xMinSite, xend = xMaxSite, y = -3.45, yend = -3.45, color = everyOtherSite), size = 1)+
    geom_text(data = outPltAnnotated.SiteYear, aes(x = xMeanSiteYear, y =-3.1, label = Year), angle = 90, hjust = 1, size = 2.5)+
    # Observations -----------------------------------------------------------
    rasterise(geom_point(aes(Xcoord, y), size = 0.1, color = 'gray'), data=outPltAnnotated, dpi=use_dpi) + # raw values
#     geom_point(aes(Xcoord, y), size = 0.1, color = 'gray')+ # raw values
    # Residual Env to SiteYear ---------------------------------------------------
    rasterise(geom_segment(aes(x = xMeanSiteYear, xend = xMeanSiteYear, y = yMeanSite, yend = yMeanSiteYear), color = '#dd1c77', size = 0.25), 
              data=outPltAnnotated, dpi=use_dpi)+
    # SiteYear Means --------------------------------------------------------------
    rasterise(geom_segment(data = outPltAnnotated.SiteYear, aes(x = xMinSiteYear, xend = xMaxSiteYear, y = yMeanSiteYear, yend = yMeanSiteYear), color = '#dd1c77', size = 1), 
              data=outPltAnnotated.SiteYear, dpi=use_dpi)+
    # Site Means -------------------------------------------------------------
    rasterise(geom_segment(data = outPltAnnotated.Site, aes(x = xMinSite, xend = xMaxSite, y = yMeanSite, yend = yMeanSite), color = 'black', size = 1), 
              data=outPltAnnotated.Site, dpi=use_dpi)+
    labs(y = 'Normalize Yield')+    
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.major.y = element_line(colour = 'darkgray'),
          panel.grid.minor.x = element_blank(),
          panel.grid.minor.y = element_line(colour = 'darkgray'),
          legend.position = ''
         )+
    scale_color_manual(values = c('white', 'Black', # Colors for alternating bar on x
                                  'Black', 'Gray'   # Colors for train/test
                                 ))+
    coord_cartesian(ylim = c(-4.15, 4.1))

variability_chart
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:45.424797Z', start_time: '2023-07-13T19:11:03.386Z'}
outPltAnnotated  %>% head

#$Xcoord  %>% max
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:51.912004Z', start_time: '2023-07-13T19:11:03.390Z'}
marginal_boxplot <- ggplot(outPltAnnotated)+
    geom_boxplot(aes(y = y, fill = Set), alpha = 0.6)+
    geom_boxplot(aes(y = y, group = Set), fill = NA)+
    scale_fill_manual(values = c('Gray', 'Black'))+
    labs(y = '')+    
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.major.y = element_line(colour = 'darkgray'),
          panel.grid.minor.x = element_blank(),
          panel.grid.minor.y = element_line(colour = 'darkgray'),
          legend.position = ''
         )+
    coord_cartesian(ylim = c(-4.15, 4.1))


marginal_density <- ggplot(outPltAnnotated)+
    geom_density(aes(y = y, color = Set))+
    scale_color_manual(values = c('Gray', 'Black'))+
    labs(y = '')+    
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.major.y = element_line(colour = 'darkgray'),
          panel.grid.minor.x = element_blank(),
          panel.grid.minor.y = element_line(colour = 'darkgray'),
          legend.position = ''
         )+
    coord_cartesian(ylim = c(-4.15, 4.1))


layout = paste(c(rep('A', times = 47), "BCC"), collapse = '')
full_plt <- variability_chart+marginal_boxplot+marginal_density+plot_layout(design = layout)
full_plt
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:51.919029Z', start_time: '2023-07-13T19:11:03.393Z'}
# ggsave(filename = '../output/variability_chart.pdf', plot = full_plt, width = 12, height = 7.5)
```



```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:51.925657Z', start_time: '2023-07-13T19:11:03.401Z'}
# Placeholder  -- vcas run belong here

if( overwrite_saved_files ){
    library(VCA)
    library(tidyverse)
    
    ModTrain <- read.csv('../output/01_mod_train.csv') |> select(-'X')
    ModTest <- read.csv('../output/01_mod_test.csv') |> select(-'X')

    ModAll <- rbind(ModTrain, ModTest) |>
        select(Pedigree, ExperimentCode, Year, y) |>
        unite(SiteYear, ExperimentCode:Year)

    ModAll$SiteYear <- as.factor(ModAll$SiteYear)
    ModAll$Pedigree <- as.factor(ModAll$Pedigree)
    print(Sys.time())
    fit <- remlMM(y ~ 1+(Pedigree)+(SiteYear)+(Pedigree):(SiteYear), ModAll, cov = TRUE)
    print(Sys.time())

    write.csv(fit$aov.tab, './vca_mod_aov_tab.csv')

    save(fit, file = "vca_mod.rda")

    print(fit$aov.tab)

    load("vca_mod.rda")

    print(fit$aov.tab)    
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:51.962771Z', start_time: '2023-07-13T19:11:03.405Z'}
# read in the VCA table results

res <- read.csv('./vca_mod_aov_tab.csv')

mk_PrVarPlot <- function(res = read.csv('./vca_mod_aov_tab.csv')){
    PrVarPlot <- res |>
        rename(`Model Term` = X) |>
        filter(`Model Term` != 'total') |>
#         mutate(`Model Term` = case_when(`Model Term` == 'error' ~ 'Error',
#                                  `Model Term` != 'error' ~ `Model Term`)) |>
#         mutate(`Model Term` = factor(`Model Term`, levels = c('Error', 'SiteYear', 'Pedigree:SiteYear', 'Pedigree'))) |>
        mutate(`Model Term` = case_when(`Model Term` == 'error' ~ 'Err.',
                                        `Model Term` == 'SiteYear' ~ 'E', 
                                        `Model Term` == 'Pedigree:SiteYear' ~ 'GxE', 
                                        `Model Term` == 'Pedigree' ~ 'G')) |>
        mutate(`Model Term` = factor(`Model Term`, levels = c('Err.', 'E', 'GxE', 'G'))) |>

    
        
        arrange(desc(`Model Term`)) |>
        mutate(C.X.Total = cumsum(X.Total)) |>
        mutate(X.Total.Lab = paste0(as.character(round(X.Total, 3)), '%')) |>
        ggplot(aes(y = `VC`, x = '1'))+
            geom_bar(aes(fill = `Model Term`), position = 'fill', stat="identity")+
            geom_label(aes(y = (C.X.Total/100)-(VC/2), label = X.Total.Lab))+
            scale_fill_manual(values = c('#f2f0f7', '#43a2ca', '#7bccc4', '#31a354'))+
            scale_y_continuous(labels = scales::percent)+
            labs(y = 'Proportion of Variance')+
            theme(legend.position = 'bottom',
                  axis.title.x = element_blank(),
                  axis.text.x = element_blank(),
                  panel.grid.major.x = element_blank(),
                  panel.grid.minor.x = element_blank()
                  )
    return(PrVarPlot)    
}


# Takes at least >3 h to run
# PrVarPlot_train <- mk_PrVarPlot(res = read.csv('./vca_mod_aov_tab_trainonly.csv'))
PrVarPlot_test <- mk_PrVarPlot(res = read.csv('./vca_mod_aov_tab.csv'))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:51.969627Z', start_time: '2023-07-13T19:11:03.409Z'}
# ggsave(filename = '../output/ProportionVariance_test.pdf', plot = PrVarPlot_test, width = 4, height = 7.5)
```


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:57.643380Z', start_time: '2023-07-13T19:11:03.415Z'}
layout = paste(
    c(rep('A', times = 100), 
    rep('B', times = 2), 
#     rep('C', times = 3), 
    rep('D', times = 10)), collapse = '')
      
full_plt <- ((variability_chart+labs(title = "A. Variability of Yield"))+
             (marginal_boxplot)+
#              (marginal_density)+
             (PrVarPlot_test+labs(title = "B. Variance Explained")))+plot_layout(design = layout)

full_plt
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:13:02.183438Z', start_time: '2023-07-13T19:11:03.418Z'}
ggsave(filename = '../output/SFigure_Variability.pdf', plot = full_plt, width = 18, height = 8)
```




```{r}
#| ExecuteTime: {end_time: '2023-07-13T18:56:44.321495Z', start_time: '2023-07-13T18:55:44.444Z'}
varPlot(form=y~ExperimentCode/Pedigree, Data=ModTrain, 
       MeanLine=list(var=c("ExperimentCode"), 
                      col=c("magenta"), lwd=c(2))
       )
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T18:56:47.423864Z', start_time: '2023-07-13T18:55:45.347Z'}
varPlot(form=y~ExperimentCode/Pedigree, Data=ModTest, 
       MeanLine=list(var=c("ExperimentCode"), 
                      col=c("magenta"), lwd=c(2))
       )
```

```{r}
varPlot(form=y~ExperimentCode*Pedigree, Data=ModTest, 
       MeanLine=list(var=c("ExperimentCode"), 
                      col=c("magenta"), lwd=c(2))
       )
```

```{r}
library(lme4)
```

```{r}
o = lmer(y~Pedigree+(1|ExperimentCode), data=ModTest)
```

```{r}
uhat = ranef(o)$ExperimentCode[[1]] # vector of EBLUPs for ExperimentCode
```

```{r}
betahat = fixef(o)
str(betahat)
```

```{r}
VCA::lmerSummary(o)
```

```{r}
# trying to make pr R2 plots
fm <- lm(y~Pedigree+ExperimentCode, data=ModTest)
```

```{r}
# install.packages('tidymodels')
# library(tidymodels)

# tidy(fm) |> 
#     mutate(Type = case_when(
#     str_detect(tidy(fm)$term, 'Intercept') ~ '.',
#     str_detect(tidy(fm)$term, 'MeanShift') & str_detect(tidy(fm)$term, ':', negate = TRUE) ~ 'G',
#     str_detect(tidy(fm)$term, 'ExperimentCode') & str_detect(tidy(fm)$term, ':', negate = TRUE)  ~ 'E',
#     str_detect(tidy(fm)$term, ':') ~ 'X'
#     )) 
```


```{r}
# install.packages('ape')
library(ape)
data(carnivora)
library(nlme)
m <- lme(log10(SW) ~ 1, random = ~ 1|Order/SuperFamily/Family/Genus, data=carnivora)
v <- varcomp(m, TRUE, TRUE)
plot(v)
```

```{r}
library(VCA)
data(sleepstudy)
fit <- remlMM(Reaction~Days+(Subject)+Days:(Subject), sleepstudy, cov=TRUE)
fit
```

```{r}
library(VCA)
```

```{r}
ModTestF = ModTest
ModTestF$ExperimentCode = as.factor(ModTestF$ExperimentCode)
ModTestF$Pedigree = as.factor(ModTestF$Pedigree)

fit <- remlMM(y~1+Pedigree+(ExperimentCode)+Pedigree:(ExperimentCode), ModTestF, cov=TRUE)
# fit
```

```{r}
names(fit)
```

```{r}
fit$aov.tab
```

```{r}
fit$aov.tab |> 
    mutate(Group = rownames(fit$aov.tab)) |>
    filter(Group != 'total') |>
    ggplot(aes(fill = Group, y = `VC`, x = 1))+
        geom_bar(position = 'fill', stat="identity")
```


```{r}
#| ExecuteTime: {end_time: '2023-07-12T14:48:24.518661Z', start_time: '2023-07-12T14:48:24.502Z'}
library(VCA)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T14:52:03.497529Z', start_time: '2023-07-12T14:48:25.203Z'}
filepath = './vca_mod.rda'

if(file.exists(filepath)){
   fit <-  load(filepath) 
} else {
    # This was a standalone script I wrote so it could run on the workstation.
#     library(VCA)
#     library(tidyverse)

#     ModTrain <- read.csv('../output/01_mod_train.csv') |> select(-'X')
#     ModTest <- read.csv('../output/01_mod_test.csv') |> select(-'X')

#     ModAll <- rbind(ModTrain, ModTest) |>
#             select(Pedigree, ExperimentCode, Year, y) |>
#             unite(SiteYear, ExperimentCode:Year)

#     ModAll$SiteYear <- as.factor(ModAll$SiteYear)
#     ModAll$Pedigree <- as.factor(ModAll$Pedigree)
#     print(Sys.time())
#     fit <- remlMM(y ~ 1+Pedigree+(SiteYear)+Pedigree:(SiteYear), ModAll, cov = TRUE)
#     print(Sys.time())

#     save(fit, file = "vca_mod.rda")
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T14:52:03.497529Z', start_time: '2023-07-12T14:48:25.203Z'}
#| code_folding: [0]
# The R script run ----
# library(VCA)
# library(tidyverse)

# ModTrain <- read.csv('../output/01_mod_train.csv') |> select(-'X')
# ModTest <- read.csv('../output/01_mod_test.csv') |> select(-'X')

# ModAll <- rbind(ModTrain, ModTest) |>
#         select(Pedigree, ExperimentCode, Year, y) |>
#         unite(SiteYear, ExperimentCode:Year)

# ModAll$SiteYear <- as.factor(ModAll$SiteYear)
# ModAll$Pedigree <- as.factor(ModAll$Pedigree)
# print(Sys.time())
# fit <- remlMM(y ~ 1+Pedigree+(SiteYear)+Pedigree:(SiteYear), ModAll, cov = TRUE)
# print(Sys.time())

# save(fit, file = "vca_mod.rda")

# print(fit$aov.tab)

# load("vca_mod.rda")

# print(fit$aov.tab)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T14:56:46.343517Z', start_time: '2023-07-12T14:53:07.706Z'}
# fm <- load('./vca_mod.rda')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T14:57:55.233247Z', start_time: '2023-07-12T14:57:55.215Z'}
str(fm)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T14:57:45.374484Z', start_time: '2023-07-12T14:57:45.319Z'}
str(fit)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T15:00:25.212639Z', start_time: '2023-07-12T15:00:25.191Z'}
fit$aov.tab
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T15:00:26.804435Z', start_time: '2023-07-12T15:00:26.568Z'}
fit$aov.tab |> 
    mutate(Group = rownames(fit$aov.tab)) |>
    filter(Group != 'total') |>
    ggplot(aes(fill = Group, y = `VC`, x = 1))+
        geom_bar(position = 'fill', stat="identity")
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T14:52:38.231028Z', start_time: '2023-07-12T14:52:38.211Z'}
str(fit)
print(fit$aov.tab)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T16:58:02.083059Z', start_time: '2023-07-12T16:58:02.028Z'}
ModAll <- rbind(ModTrain, ModTest) |>
        select(Pedigree, ExperimentCode, Year, y) |>
        unite(SiteYear, ExperimentCode:Year)

ModAll$SiteYear <- as.factor(ModAll$SiteYear)
ModAll$Pedigree <- as.factor(ModAll$Pedigree)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T17:02:50.329770Z', start_time: '2023-07-12T17:01:46.590Z'}
tic <- Sys.time()
# fit <- remlMM(y ~ 1+Pedigree+(SiteYear)+Pedigree:(SiteYear), ModAll[sample(1:41513, 1000), ], cov = TRUE)
fit <- remlMM(y ~ 1+(Pedigree)+(SiteYear)+(Pedigree):(SiteYear), ModAll[sample(1:41513, 10000), ], cov = TRUE)
toc <- Sys.time()
print(toc - tic)


fit$aov.tab
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T17:02:50.532828Z', start_time: '2023-07-12T17:01:47.053Z'}
fit$aov.tab |> 
    mutate(Group = rownames(fit$aov.tab)) |>
    filter(Group != 'total') |>
    ggplot(aes(fill = Group, y = `VC`, x = 1))+
        geom_bar(position = 'fill', stat="identity")
```








```{r}
#| ExecuteTime: {end_time: '2023-07-12T15:35:08.893188Z', start_time: '2023-07-12T15:35:07.713Z'}
GClusters <- read.csv('../output/01_G_Clusters_MeanShift.csv') %>% select(-'X')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T15:35:09.113560Z', start_time: '2023-07-12T15:35:08.000Z'}
GClusters |> 
    pivot_longer(cols = names(select(GClusters, -c('Pedigree', 'F', 'M')))) |> 
    group_by(name) |> 
    summarise(n = max(value)) |>
    ggplot(aes(x = name, y = n, label = n))+
    geom_line(aes(group = 1))+
    geom_label()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T15:35:09.490254Z', start_time: '2023-07-12T15:35:09.306Z'}
ModAllMeanShift <- left_join(rbind(ModTest, ModTrain), GClusters[, c('Pedigree', 'F', 'M', 'bw150')]) |> 
    rename(MeanShift = bw150) |> 
    mutate(MeanShift = as.character(MeanShift)) |>
    select(MeanShift, ExperimentCode, Year, y) |>
    unite(SiteYear, ExperimentCode:Year)

ModAllMeanShift$SiteYear <- as.factor(ModAllMeanShift$SiteYear)
ModAllMeanShift$MeanShift <- as.factor(ModAllMeanShift$MeanShift)

ModAllMeanShift |> head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T15:35:22.032111Z', start_time: '2023-07-12T15:35:22.021Z'}
print(Sys.time())
fm.ms <- remlMM(y ~ 1+MeanShift+(SiteYear)+MeanShift:(SiteYear), ModAllMeanShift, cov = TRUE)
print(Sys.time())

fm.ms$aov.tab |> 
    mutate(Group = rownames(fit$aov.tab)) |>
    filter(Group != 'total') |>
    ggplot(aes(fill = Group, y = `VC`, x = 1))+
        geom_bar(position = 'fill', stat="identity")
```


```{r}
#| ExecuteTime: {end_time: '2023-07-12T15:10:44.183290Z', start_time: '2023-07-12T15:10:43.096Z'}
varPlot(form=y~ExperimentCode/MeanShift, Data=ModTestMeanShift, 
       MeanLine=list(var=c("ExperimentCode"), 
                      col=c("magenta"), lwd=c(2))
       )
```

```{r}
#| ExecuteTime: {start_time: '2023-07-12T15:33:58.278Z'}
print(Sys.time())
fm.ms <- remlMM(y ~ 1+(MeanShift)+(SiteYear)+(MeanShift):(SiteYear), ModAllMeanShift, cov = TRUE)
print(Sys.time())
```


```{r}
#| ExecuteTime: {end_time: '2023-07-12T16:24:45.495822Z', start_time: '2023-07-12T16:09:14.756Z'}
tic <- Sys.time()
# 1+MeanShift+(SiteYear)+MeanShift:(SiteYear)
fm.ms <- remlVCA(
#     y ~ (MeanShift)+(SiteYear)+(MeanShift):(SiteYear), 
    y ~ MeanShift+(SiteYear)+MeanShift:(SiteYear), 
                 ModAllMeanShift[sample(1:41513, 15000), ], # FIXME downsampled
                 VarVC=FALSE # set to avoid computationally expensie step of calculating the variance-covariance matrix
                )
toc <- Sys.time()
print(toc - tic)

# 15000 15.51209 mins
```


```{r}
#| ExecuteTime: {end_time: '2023-07-12T16:08:12.588490Z', start_time: '2023-07-12T16:08:12.446Z'}
# for this model:
# y ~ (MeanShift)+(SiteYear)+(MeanShift):(SiteYear), 
data.frame(
    nObs = c(
        1000,
        5000,
        10000,
        15000
    ),
    Secs = c(
        0.4553907,
        26.16586,
        180.847936,
        840.38169
    )) |>
    mutate(SpObs = Secs/(nObs)) |>
    ggplot(aes(nObs, SpObs))+
        geom_line()+
        geom_point()+
        scale_y_log10()
```


```{r}
#| ExecuteTime: {end_time: '2023-07-12T16:03:16.993848Z', start_time: '2023-07-12T15:49:11.910Z'}
(1.808479e-06*(15000**2))/60
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T16:56:27.088479Z', start_time: '2023-07-12T16:56:27.069Z'}
fm.ms$aov.tab
```

```{r}
#| ExecuteTime: {end_time: '2023-07-12T16:56:30.247159Z', start_time: '2023-07-12T16:56:30.039Z'}
fm.ms$aov.tab |> 
    mutate(Group = rownames(fm.ms$aov.tab)) |>
    filter(Group != 'total') |>
    ggplot(aes(fill = Group, y = `VC`, x = 1))+
        geom_bar(position = 'fill', stat="identity")
```

### Same with mean shift groups

```{r}
# GClusters <- read.csv('../output/01_G_Clusters_MeanShift.csv') %>% select(-'X')
```

```{r}
# GClusters |> 
#     pivot_longer(cols = names(select(GClusters, -c('Pedigree', 'F', 'M')))) |> 
#     group_by(name) |> 
#     summarise(n = max(value)) |>
#     ggplot(aes(x = name, y = n, label = n))+
#     geom_line(aes(group = 1))+
#     geom_label()
```

```{r}
# ModTestMeanShift <- left_join(ModTest, GClusters[, c('Pedigree', 'F', 'M', 'bw150')]) |> 
#     rename(MeanShift = bw150) |> 
#     mutate(MeanShift = as.character(MeanShift))
# ModTestMeanShift
```

```{r}
# varPlot(form=y~ExperimentCode/MeanShift, Data=ModTestMeanShift, 
#        MeanLine=list(var=c("ExperimentCode"), 
#                       col=c("magenta"), lwd=c(2))
#        )
```

```{r}
# fm <- lm(y ~ ExperimentCode*MeanShift, data=ModTestMeanShift)
```

```{r}
# # install.packages('tidymodels')
# library(tidymodels)
```

```{r}
# tidy(fm) |> 
#     mutate(Type = case_when(
#     str_detect(tidy(fm)$term, 'Intercept') ~ '.',
#     str_detect(tidy(fm)$term, 'MeanShift') & str_detect(tidy(fm)$term, ':', negate = TRUE) ~ 'G',
#     str_detect(tidy(fm)$term, 'ExperimentCode') & str_detect(tidy(fm)$term, ':', negate = TRUE)  ~ 'E',
#     str_detect(tidy(fm)$term, ':') ~ 'X'
#     )) |> 
#     ggplot(aes(Type, abs(estimate)))+
#         geom_violin()+
#         geom_boxplot()
```



```{r}
# GClusters <- read.csv('../output/01_OPTICS.csv') %>% select(-'X')

# GClusters |> 
#     pivot_longer(cols = names(select(GClusters, -c('Pedigree', 'F', 'M')))) |> 
#     group_by(name) |> 
#     summarise(n = max(value)) |>
#     ggplot(aes(x = name, y = n, label = n))+
#     geom_line(aes(group = 1))+
#     geom_label()
```




```{r}
# GClusters
```

```{r}
# varPlot(form=LM_0~ExperimentCode/M, Data=ModTest)
```


```{r}
# varPlot(form=BLUP_0~ExperimentCode/M, Data=ModTest)
```

```{r}
# ModTestTemp = ModTest[, c('BLUP_0', 'y', 'ExperimentCode', 'M')]
# ModTestTemp$BLUP_0 <- ModTestTemp$BLUP_0 - ModTestTemp$y

# varPlot(form=BLUP_0~ExperimentCode/M, Data=ModTestTemp,
#        MeanLine=list(var=c("ExperimentCode"), 
#                       col=c("magenta"), lwd=c(2))
       
#        )
```





# Simulation Study 
Demonstrate ensembling benefit between two models in simple simulation.

```{r}
# r1 = rnorm(mean = 0, sd = 1, n = 100000)
# r2 = rnorm(mean = 0, sd = 2, n = 100000)

# var(r1)+var(r2)
# var(r1+r2)

# print(var(r1))
# var(.5*r1 + .5*r2)

# scale_by_var <- function(x){return((1/var(x))*x)}

# hist(scale_by_var(r1)+scale_by_var(r2))
```

```{r}
# # no slope
# # slope 
# n = 100000
# var1 = 5
# var2 = 10

# xs <- seq(0, 100, length.out = n)
# ys <- 0+1*xs
# # no bias
# y1 <- ys + rnorm(n = n, mean = 0, sd = sqrt(var1))
# y2 <- ys + rnorm(n = n, mean = 0, sd = sqrt(var2))

# yhat_vars  <- unlist(map(list(y1, y2), function(e){var(e)}))
# yhat_rmses <- unlist(map(list(y1, y2), function(e){sqrt((sum((ys-e)**2)/n))}))
# wght_vars  <- (1/yhat_vars)/sum(1/yhat_vars)
# wght_rmses <- (1/yhat_rmses)/sum(1/yhat_rmses)

# e1 <- 0.5*y1 + 0.5*y2
# e2 <- wght_vars[1]*y1 + wght_vars[2]*y2
# e3 <- wght_rmses[1]*y1 + wght_rmses[2]*y2

# data <- data.frame(xs, ys, y1, y2, 
#                    unif = e1, 
#                    var = e2, 
#                    rmse = e3)
# plt_data <- data |> 
#   select(-xs) |> 
#   pivot_longer(cols = c(y1, y2, unif, var, rmse)) |> 
#   rename(y_pred = value) 
```

```{r}
# plt_data |> 
#   ggplot()+
#     geom_boxplot(aes(x = ys - y_pred, color = name))
```

```{r}
# data.frame(
#   name = c('y1', 'y2', 'e1', 'e2', 'e3'),
#   var = unlist(map(list(y1, y2, e1, e2, e3), function(e){var(e)}))
# )
```

```{r}
# # Case where Var == MSE
# obs <- rnorm(n = 1e+05, mean = 0, sd = sqrt(5))

# calc_disp <- function(obs, true_val = 0){
#   obs_var  <- sum((obs - mean(obs))**2)/length(obs)
#   obs_sd   <- sqrt(obs_var)
#   obs_mse  <- (sum((obs-true_val)**2)/length(obs))
#   obs_rmse <- sqrt(obs_mse)
#   return(data.frame(obs_var, obs_mse, obs_sd, obs_rmse))
# }

# calc_disp(obs = rnorm(n = 1e+05, mean = 0, sd = sqrt(5)), 
#           true_val = 0)

# # Case where Var != MSE
# calc_disp(obs = unlist(map(seq(0, 100, length.out = 1e+05), 
#                            function(x){rnorm(n = 1, mean = x, sd = sqrt(5))})), 
#           true_val = seq(0, 1, length.out = 1e+05))
```

```{r}
# # how does the benefit change as the variance of errors shifts?
# run_sim <- function(
#     n = 100000,
#     var1 = 5,
#     var2 = 10
#   ){
  
#   xs <- seq(0, 100, length.out = n)
#   ys <- 0+1*xs
#   # no bias
#   y1 <- ys + rnorm(n = n, mean = 0, sd = sqrt(var1))
#   y2 <- ys + rnorm(n = n, mean = 0, sd = sqrt(var2))
  
#   yhat_vars  <- unlist(map(list(y1, y2), function(e){var(e)}))
#   yhat_rmses <- unlist(map(list(y1, y2), function(e){sqrt((sum((ys-e)**2)/n))}))
#   wght_vars  <- (1/yhat_vars)/sum(1/yhat_vars)
#   wght_rmses <- (1/yhat_rmses)/sum(1/yhat_rmses)
  
#   e1 <- 0.5*y1 + 0.5*y2
#   e2 <- wght_vars[1]*y1 + wght_vars[2]*y2
#   e3 <- wght_rmses[1]*y1 + wght_rmses[2]*y2
  
#   data <- data.frame(xs, ys, y1, y2, 
#                      unif = e1, 
#                      var = e2, 
#                      rmse = e3)
#   plt_data <- data |> 
#     select(-xs) |> 
#     pivot_longer(cols = c(y1, y2, unif, var, rmse)) |> 
#     rename(y_pred = value) |> 
#     # Calc RMSE
#     group_by(name) |>                
#     mutate(y_se = (ys - y_pred)**2) |> 
#     summarise(y_rmse = sqrt(mean(y_se))) |> 
#     ungroup() |> 
#     mutate(var1 = var1,
#            var2 = var2)
  
#   return(plt_data)
# }

# sim_data <- do.call(rbind, 
#         map(seq(0.01, 1, length.out = 100), 
#             function(var2){
#               run_sim(
#                 n = 100000,
#                 var1 = 1,
#                 var2 = var2)
#               })
#         ) 

# # where on the graph does rmse become best?
# xmin_rmse_best <- sim_data |> 
#   pivot_wider(names_from = 'name', values_from = 'y_rmse') |> 
#   filter(y2>rmse) |> 
#   summarise(var2 = min(var2)) |> 
#   unlist()

# sim_data |> 
#   ggplot()+
#     geom_vline(xintercept = xmin_rmse_best, linetype = 'dashed')+
#     geom_text(aes(x = 0.25, y = 0, label = round(xmin_rmse_best, digits = 4)))+
#     geom_line(aes(x = var2, y = y_rmse, color = name))+
#     theme_minimal()+
#     theme(legend.position = 'bottom')+
#     labs(x = 'Ratio of Residual Variances: y2/y1',
#          y = 'RMSE of Predictions')
```

```{r}
# sim_data |> 
#   mutate(line_type = case_when(name != 'var'~ 'a',
#                                name == 'var'~ 'b')) |> 
#   ggplot()+
#     geom_vline(xintercept = xmin_rmse_best, linetype = 'dashed')+
#     geom_text(aes(x = 0.25, y = 0, label = round(xmin_rmse_best, digits = 4)))+
#     geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type))+
#     theme_minimal()+
#     theme(legend.position = 'bottom')+
#     labs(x = 'Ratio of Residual Variances: y2/y1',
#          y = 'RMSE of Predictions')+
#     scale_color_manual(values = c('orange', 'black', 'red', 'cornflowerblue', 'cornflowerblue' ))
```

```{r}
# rbind(head(sim_data),tail(sim_data))
```

```{r}
# # how does the benefit change if there is bias in in one of the residuals??
# run_sim2 <- function(
#     n = 100000,
#     mean1 = 0,
#     mean2 = 1, 
#     var1 = 5,
#     var2 = 10
#   ){
  
#   xs <- seq(0, 100, length.out = n)
#   ys <- 0+1*xs
#   # no bias
#   y1 <- ys + rnorm(n = n, mean = mean1, sd = sqrt(var1))
#   y2 <- ys + rnorm(n = n, mean = mean2, sd = sqrt(var2))
  
#   yhat_vars  <- unlist(map(list(y1, y2), function(e){var(e)}))
#   yhat_rmses <- unlist(map(list(y1, y2), function(e){sqrt((sum((ys-e)**2)/n))}))
#   wght_vars  <- (1/yhat_vars)/sum(1/yhat_vars)
#   wght_rmses <- (1/yhat_rmses)/sum(1/yhat_rmses)
  
#   e1 <- 0.5*y1 + 0.5*y2
#   e2 <- wght_vars[1]*y1 + wght_vars[2]*y2
#   e3 <- wght_rmses[1]*y1 + wght_rmses[2]*y2
  
#   data <- data.frame(xs, ys, y1, y2, 
#                      unif = e1, 
#                      var = e2, 
#                      rmse = e3)
#   plt_data <- data |> 
#     select(-xs) |> 
#     pivot_longer(cols = c(y1, y2, unif, var, rmse)) |> 
#     rename(y_pred = value) |> 
#     # Calc RMSE
#     group_by(name) |>                
#     mutate(y_se = (ys - y_pred)**2) |> 
#     summarise(y_rmse = sqrt(mean(y_se))) |> 
#     ungroup() |> 
#     mutate(mean1 = mean1,
#            mean2 = mean2)
  
#   return(plt_data)
# }

# sim_data2 <- do.call(rbind, 
#         map(seq(0.01, 2.5, length.out = 20), 
#             function(mean2){
#               run_sim2(
#                 n = 100000,
#                 mean1 = 0,
#                 mean2 = mean2, 
#                 var1 = 1,
#                 var2 = 1)
#               })
#         ) 

# # where on the graph does rmse become best?
# xmin_rmse_best2 <- sim_data2 |> 
#   pivot_wider(names_from = 'name', values_from = 'y_rmse') |> 
#   filter(y2>rmse) |> 
#   summarise(mean2 = min(mean2)) |> 
#   unlist()

# sim_data2 |> 
#   ggplot()+
#     geom_vline(xintercept = xmin_rmse_best2, linetype = 'dashed')+
#     geom_text(aes(x = 0.25, y = 0, label = round(xmin_rmse_best, digits = 4)))+
#     geom_line(aes(x = mean2, y = y_rmse, color = name))+
#     theme_minimal()+
#     theme(legend.position = 'bottom')+
#     labs(x = 'Residual mean in y2',
#          y = 'RMSE of Predictions')
```

```{r}
# rbind(head(sim_data2),tail(sim_data2))
```

```{r}
# # how does the benefit change if there is bias in in one of the residuals??
# run_sim3 <- function(
#     n = 100000,
#     mean1 = 0,
#     mean2 = 1, 
#     var1 = 5,
#     var2 = 10
#   ){
  
#   xs <- seq(0, 100, length.out = n)
#   ys <- 0+1*xs
#   # no bias
#   y1 <- ys + rnorm(n = n, mean = mean1, sd = sqrt(var1))
#   y2 <- ys + rnorm(n = n, mean = mean2, sd = sqrt(var2))
  
#   yhat_vars  <- unlist(map(list(y1, y2), function(e){var(e)}))
#   yhat_rmses <- unlist(map(list(y1, y2), function(e){sqrt((sum((ys-e)**2)/n))}))
#   wght_vars  <- (1/yhat_vars)/sum(1/yhat_vars)
#   wght_rmses <- (1/yhat_rmses)/sum(1/yhat_rmses)
  
#   e1 <- 0.5*y1 + 0.5*y2
#   e2 <- wght_vars[1]*y1 + wght_vars[2]*y2
#   e3 <- wght_rmses[1]*y1 + wght_rmses[2]*y2
  
#   data <- data.frame(xs, ys, y1, y2, 
#                      unif = e1, 
#                      var = e2, 
#                      rmse = e3)
#   plt_data <- data |> 
#     select(-xs) |> 
#     pivot_longer(cols = c(y1, y2, unif, var, rmse)) |> 
#     rename(y_pred = value) |> 
#     # Calc RMSE
#     group_by(name) |>                
#     mutate(y_se = (ys - y_pred)**2) |> 
#     summarise(y_rmse = sqrt(mean(y_se))) |> 
#     ungroup() |> 
#     mutate(mean1 = mean1,
#            mean2 = mean2,
#            var1 = var1,
#            var2 = var2)
  
#   return(plt_data)
# }


# # params <- expand.grid(
# #   mean_shift = c(0, 1),
# #   var_shift = c(seq(0.01, 0.99, length.out = 50), seq(1, 100, length.out = 90))
# # )


# # sim_data3 <- do.call(rbind, 
# #         map(seq(1, nrow(params)), 
# #             function(i){
# #               run_sim3(
# #                 n = 100000,
# #                 mean1 = 0,
# #                 mean2 = unlist(params[i, 'mean_shift']), 
# #                 var1 = 1,
# #                 var2 = unlist(params[i, 'var_shift']))
# #               })
# #         ) 

# # # where on the graph does rmse become best?
# # xmin_rmse_best3 <- sim_data3 |> 
# #   pivot_wider(names_from = 'name', values_from = 'y_rmse') |> 
# #   filter(y2>rmse) |> 
# #   summarise(mean2 = min(mean2)) |> 
# #   unlist()

# # sim_data3 <- sim_data3 |> 
# #   mutate(line_type = case_when(name != 'var'~ 'a',
# #                                name == 'var'~ 'b'))
# # sd3.1 <- sim_data3 |> 
# #   ggplot()+
# #     geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type))+
# #     theme_minimal()+
# #     theme(legend.position = 'bottom')+
# #     labs(x = 'Ratio of Residual Variances: y2/y1',
# #          y = 'RMSE of Predictions')+
# #     facet_grid(.~mean2)+
# #     scale_color_manual(values = c('orange', 'black', 'red', 'cornflowerblue', 'cornflowerblue' ))


# # sd3.2 <- sim_data3 |> 
# #   ggplot()+
# #     geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type))+
# #     theme_minimal()+
# #     theme(legend.position = 'bottom')+
# #     labs(x = 'Ratio of Residual Variances: y2/y1',
# #          y = 'RMSE of Predictions')+
# #     facet_grid(.~mean2)+
# #     scale_color_manual(values = c('orange', 'black', 'red', 'cornflowerblue', 'cornflowerblue' ))+
# #   coord_cartesian(xlim = c(0, 1.5), ylim = c(0, 3))

# # library(patchwork)

# # sd3.1/sd3.2
```

```{r}
# rbind(head(sim_data3),tail(sim_data3))
```

```{r}
# plt.1.1 <- sim_data3 |> 
#     filter(var2 <=1) |>
#     filter(mean2 == 0) |>
#     ggplot()+
#         geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type))+
#         theme_minimal()+
#         theme(legend.position = 'bottom')+
#         labs(x = '',
#              y = 'RMSE of Predictions',
#              subtitle = 'Unbiased Error')+
#         scale_color_manual(values = c('orange', 'black', 'red', 'cornflowerblue', 'cornflowerblue' ))

# plt.1.2 <- sim_data3 |> 
#     filter(mean2 == 0) |>
#     ggplot()+
#         geom_rect(aes(xmin= 0, xmax= 1, ymin= 0, ymax= 1.1), fill = NA, color = 'Gray')+        
#         geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type))+
#         theme_minimal()+
#         theme(legend.position = '')+
#         labs(x = '',
#              y = '',
#              subtitle = '')+
#         scale_color_manual(values = c('orange', 'black', 'red', 'cornflowerblue', 'cornflowerblue' ))

# plt.2.1 <- sim_data3 |> 
#     filter(var2 <=1) |>
#     filter(mean2 == 1) |>
#     ggplot()+
#         geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type))+
#         theme_minimal()+
#         theme(legend.position = 'bottom')+
#         labs(x = 'Variance of Model 2',
#              y = 'RMSE of Predictions',
#              subtitle = 'Biased Error')+
#         scale_color_manual(values = c('orange', 'black', 'red', 'cornflowerblue', 'cornflowerblue' ))

# plt.2.2 <- sim_data3 |> 
#     filter(mean2 == 1) |>
#     ggplot()+
#         geom_rect(aes(xmin= 0, xmax= 1, ymin= 0, ymax= 1.1), fill = NA, color = 'Gray')+        
#         geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type))+
#         theme_minimal()+
#         theme(legend.position = 'bottom')+
#         labs(x = 'Variance of Model 2',
#              y = '',
#              subtitle = '')+
#         scale_color_manual(values = c('orange', 'black', 'red', 'cornflowerblue', 'cornflowerblue' ))
```

```{r}
# layout ="
# AAB
# CCD"

# plt.1.1+plt.1.2+plt.2.1+plt.2.2+plot_layout(design = layout)
```

```{r}
# sim_data3 |> 
# #     filter(var2 <=1) |>
#     filter(mean2 == 1) |>
#     ggplot()+
#         geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type))+
#         theme_minimal()+
#         theme(legend.position = 'bottom')+
#         labs(x = 'Variance of Model 2',
#              y = 'RMSE of Predictions',
#              subtitle = 'Biased Error')+
#         scale_color_manual(values = c('orange', 'black', 'red', 'cornflowerblue', 'cornflowerblue' ))+
#         coord_cartesian(xlim = c(0, 7), ylim = c(0.5, 2))
```



```{r}
# run_sim3 <- function(
#     n = 100000,
#     mean1 = 0,
#     mean2 = 1, 
#     var1 = 5,
#     var2 = 10
#   ){
  
#   xs <- seq(0, 100, length.out = n)
#   ys <- 0+1*xs
#   # no bias
#   y1 <- ys + rnorm(n = n, mean = mean1, sd = sqrt(var1))
#   y2 <- ys + rnorm(n = n, mean = mean2, sd = sqrt(var2))
  
#   yhat_vars  <- unlist(map(list(y1, y2), function(e){var(e)}))
#   yhat_stds  <- unlist(map(list(y1, y2), function(e){sqrt(var(e))}))
#   yhat_rmses <- unlist(map(list(y1, y2), function(e){sqrt((sum((ys-e)**2)/n))}))
#   wght_vars  <- (1/yhat_vars)/sum(1/yhat_vars)
#   wght_stds  <- (1/yhat_stds)/sum(1/yhat_stds)
#   wght_rmses <- (1/yhat_rmses)/sum(1/yhat_rmses)
  
#   e1 <- 0.5*y1 + 0.5*y2
#   e2 <- wght_vars[1]*y1 + wght_vars[2]*y2
#   e3 <- wght_stds[1]*y1 + wght_stds[2]*y2
#   e4 <- wght_rmses[1]*y1 + wght_rmses[2]*y2
  
#   data <- data.frame(xs, ys, y1, y2, 
#                      unif = e1, 
#                      var = e2, 
#                      std = e3,
#                     rmse = e4)
    
#   plt_data <- data |> 
#     select(-xs) |> 
#     pivot_longer(cols = c(y1, y2, unif, var, std, rmse)) |> 
#     rename(y_pred = value) |> 
#     # Calc RMSE
#     group_by(name) |>                
#     mutate(y_se = (ys - y_pred)**2) |> 
#     summarise(y_rmse = sqrt(mean(y_se))) |> 
#     ungroup() |> 
#     mutate(mean1 = mean1,
#            mean2 = mean2,
#            var1 = var1,
#            var2 = var2)
  
#   return(plt_data)
# }


# sim_data_same_mean <- do.call(rbind, 
#         map(c(seq(0.01, 4.99, by = 0.01), seq(5, 100)), 
#             function(i){
#               run_sim3(
#                 n = 100000,
#                 mean1 = 0,
#                 mean2 = 0, 
#                 var1 = 1,
#                 var2 = i)
#               })
#         ) 


# sim_data_shift_mean <- do.call(rbind, 
#         map(c(seq(0.01, 4.99, by = 0.01), seq(5, 100)), 
#             function(i){
#               run_sim3(
#                 n = 100000,
#                 mean1 = 0,
#                 mean2 = 1, 
#                 var1 = 1,
#                 var2 = i)
#               })
#         ) 

```



```{r}
# ## Same Mean -----------------------------------------------------------------
# # where on the graph does rmse become best?
# xmin_rmse_best <- sim_data_same_mean |> 
#   pivot_wider(names_from = 'name', values_from = 'y_rmse') |> 
#   filter(y2>rmse) |> 
#   summarise(var2 = min(var2)) |> 
#   unlist()

# # where does it stop being best?
# xmin_rmse_second_best <- sim_data_same_mean |> 
#     filter(var2 > xmin_rmse_best) |>
#     pivot_wider(names_from = 'name', values_from = 'y_rmse') |> 
#     filter(y1<rmse) |> 
#     summarise(var2 = min(var2)) |> 
#     unlist()



# cleaned_sim_same_mean <- sim_data_same_mean |> 
#     mutate(line_type = case_when(((name != 'var') & (name != 'std')) ~ 'solid',
#                                  name == 'var' ~ 'dashed',
#                                  name == 'std' ~ 'dotted')) |> 
#     mutate(line_type = factor(line_type, levels= c('solid', 'dashed', 'dotted'))) |>
#     mutate(name = case_when(name == 'rmse' ~ 'RMSE', 
#                            name == 'unif' ~ 'Unif', 
#                            name == 'var' ~ 'Var', 
#                            name == 'std' ~ 'StD', 
#                            name == 'y1' ~ 'Model 1',
#                            name == 'y2' ~ 'Model 2' 
#                            )) |>
#     mutate(name = factor(name, levels = c('RMSE', 'Unif', 'Var', 'StD', 'Model 1', 'Model 2'))) 

# plt1.1 <- cleaned_sim_same_mean |>
#     ggplot()+
#     geom_vline(xintercept = xmin_rmse_best, linetype = 'dashed')+
#     geom_label(aes(x = xmin_rmse_best, y = 1.05, label = round(xmin_rmse_best, digits = 4)))+
#     geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type), size = 1)+
#     theme_classic()+
#     theme(legend.position = '')+
#     labs(x = 'Model 2 Error Variance',
#          y = 'RMSE of Predictions',
#         subtitle = 'Unbiased Errors')+
#     scale_color_manual(values = c('orange', 'red', 'blue', 'cornflowerblue', 'gray', 'black'))+
#     coord_cartesian(xlim = c(0, 1.1), ylim = c(0, 1.1))

# plt1.1

# plt1.2 <- cleaned_sim_same_mean |>
#     ggplot()+
#     geom_rect(aes(xmin= 0, xmax= 1, ymin= 0, ymax= 1.1), fill = 'lightgray', color = 'lightgray')+
#     geom_vline(xintercept = xmin_rmse_second_best, linetype = 'dashed')+
#     geom_label(aes(x = xmin_rmse_second_best, y = 10, label = round(xmin_rmse_second_best, digits = 4)))+
#     geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type), size = 1)+
#     theme_classic()+
# #     theme(legend.position = 'bottom')+
#     labs(x = 'Model 2 Error Variance',
#          y = 'RMSE of Predictions',
#         subtitle = '')+
#     scale_color_manual(values = c('orange', 'red', 'blue', 'cornflowerblue', 'gray', 'black'))

# plt1.2
```





```{r}
# ## Same Mean -----------------------------------------------------------------
# # where on the graph does rmse become best?
# xmin_rmse_best_mean_shift <- sim_data_shift_mean |> 
#   pivot_wider(names_from = 'name', values_from = 'y_rmse') |> 
#   filter(y2>rmse) |> 
#   summarise(var2 = min(var2)) |> 
#   unlist()

# # where does it stop being best?
# xmin_rmse_second_best_mean_shift <- sim_data_shift_mean |> 
#     filter(var2 > xmin_rmse_best) |>
#     pivot_wider(names_from = 'name', values_from = 'y_rmse') |> 
#     filter(y1<rmse) |> 
#     summarise(var2 = min(var2)) |> 
#     unlist()

# cleaned_sim_shift_mean <- sim_data_shift_mean |> 
#     mutate(line_type = case_when(((name != 'var') & (name != 'std')) ~ 'solid',
#                                  name == 'var' ~ 'dashed',
#                                  name == 'std' ~ 'dotted')) |> 
#     mutate(line_type = factor(line_type, levels= c('solid', 'dashed', 'dotted'))) |>
#     mutate(name = case_when(name == 'rmse' ~ 'RMSE', 
#                            name == 'unif' ~ 'Unif', 
#                            name == 'var' ~ 'Var', 
#                            name == 'std' ~ 'StD', 
#                            name == 'y1' ~ 'Model 1',
#                            name == 'y2' ~ 'Model 2' 
#                            )) |>
#     mutate(name = factor(name, levels = c('RMSE', 'Unif', 'Var', 'StD', 'Model 1', 'Model 2'))) 

# plt2.1 <- cleaned_sim_shift_mean |>
#     ggplot()+
#     geom_vline(xintercept = xmin_rmse_best_mean_shift, linetype = 'dashed')+
#     geom_label(aes(x = xmin_rmse_best_mean_shift, y = 2.5, label = round(xmin_rmse_best, digits = 4)))+

#     geom_vline(xintercept = xmin_rmse_second_best_mean_shift, linetype = 'dashed')+
#     geom_label(aes(x = xmin_rmse_second_best_mean_shift, y = 2.5, label = round(xmin_rmse_second_best_mean_shift, digits = 4)))+

#     geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type), size = 1)+
#     theme_classic()+
#     theme(legend.position = '')+
#     labs(x = 'Model 2 Error Variance',
#          y = 'RMSE of Predictions',
#         subtitle = '')+
#     scale_color_manual(values = c('orange', 'red', 'blue', 'cornflowerblue', 'gray', 'black'))+
#     coord_cartesian(xlim = c(0, 5.5), ylim = c(0.6, 2.5))

# plt2.1

# plt2.2 <- cleaned_sim_shift_mean |>
#     ggplot()+
#     geom_rect(aes(xmin= 0, xmax= 5.5, ymin= 0.6, ymax= 2.5), fill = 'lightgray', color = 'lightgray')+
#     geom_vline(xintercept = xmin_rmse_second_best, linetype = 'dashed')+
#     geom_label(aes(x = xmin_rmse_second_best, y = 10, label = round(xmin_rmse_second_best, digits = 4)))+
#     geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type), size = 1)+
#     theme_classic()+
#     labs(x = 'Model 2 Error Variance',
#          y = 'RMSE of Predictions',
#         subtitle = '')+
#     scale_color_manual(values = c('orange', 'red', 'blue', 'cornflowerblue', 'gray', 'black'))+
#     coord_cartesian(ylim = c(0.6, 10))

# plt2.2
```

```{r}
# layout ="
# AAABB
# CCCDD"

# multiplt <- plt1.1+plt1.2+plt2.1+plt2.2+plot_layout(design = layout)
# multiplt
```

```{r}
# ggsave("../output/SFigure5.pdf", plot = multiplt, width = 12, height = 7.5)
```







```{r}
# library(tidyverse)
# library(patchwork)

run_sim_ensemble <- function(
    mean1 = 0,
    mean2 = 1, 
    var1 = 5,
    var2 = 10,
    xs = seq(0, 100, length.out = 100000)
  ){
    n <- length(xs)
    ys <- 0+1*xs
    y1 <- ys + rnorm(n = n, mean = mean1, sd = sqrt(var1))
    y2 <- ys + rnorm(n = n, mean = mean2, sd = sqrt(var2))

    yhat_vars  <- unlist(map(list(y1, y2), function(e){var(e)}))
    yhat_stds  <- unlist(map(list(y1, y2), function(e){sqrt(var(e))}))
    yhat_rmses <- unlist(map(list(y1, y2), function(e){sqrt((sum((ys-e)**2)/n))}))
    wght_vars  <- (1/yhat_vars)/sum(1/yhat_vars)
    wght_stds  <- (1/yhat_stds)/sum(1/yhat_stds)
    wght_rmses <- (1/yhat_rmses)/sum(1/yhat_rmses)

    e1 <- 0.5*y1 + 0.5*y2
    e2 <- wght_vars[1]*y1 + wght_vars[2]*y2
    e3 <- wght_stds[1]*y1 + wght_stds[2]*y2
    e4 <- wght_rmses[1]*y1 + wght_rmses[2]*y2

    data <- data.frame(
        xs, ys, y1, y2, 
        unif = e1, 
        var = e2, 
        std = e3,
        rmse = e4)

    plt_data <- data |> 
        select(-xs) |> 
        pivot_longer(cols = c(y1, y2, unif, var, std, rmse)) |> 
        rename(y_pred = value) |> 
        # Calc RMSE
        group_by(name) |>                
        mutate(y_se = (ys - y_pred)**2) |> 
        summarise(y_rmse = sqrt(mean(y_se))) |> 
        ungroup() |> 
        mutate(mean1 = mean1,
               mean2 = mean2,
               var1 = var1,
               var2 = var2)

    return(plt_data)
}
```

```{r}
sim_data_same_mean <- do.call(
    rbind, 
    map(c(seq(0.01, 4.9, by = 0.01), seq(5, 50, by = 1)), 
        function(i){
            run_sim_ensemble(
                mean1 = 0,
                mean2 = 0, 
                var1 = 1,
                var2 = i,
                xs = seq(0, 100, length.out = 100000)
            )
        }
       )
) 
```

```{r}
cleaned_sim_same_mean <- sim_data_same_mean |> 
    mutate(line_type = case_when(((name != 'var') & (name != 'std')) ~ 'solid',
                                 name == 'var' ~ 'dashed',
                                 name == 'std' ~ 'dotted')) |> 
    mutate(line_type = factor(line_type, levels= c('solid', 'dashed', 'dotted'))) |>
    mutate(name = case_when(name == 'rmse' ~ 'RMSE', 
                           name == 'unif' ~ 'Unif', 
                           name == 'var' ~ 'Var', 
                           name == 'std' ~ 'StD', 
                           name == 'y1' ~ 'Model 1',
                           name == 'y2' ~ 'Model 2' 
                           )) |>
    mutate(name = factor(name, levels = c('RMSE', 'Unif', 'Var', 'StD', 'Model 1', 'Model 2'))) 
```

```{r}
plt1.1 <- cleaned_sim_same_mean |>
    ggplot()+
    geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type), size = 1)+
    theme_classic()+
    theme(legend.position = '')+
    labs(x = 'Model 2 Error Variance',
         y = 'RMSE of Predictions',
         title = 'A. Zoomed Region')+
    scale_color_manual(values = c('orange', 'red', 'blue', 'cornflowerblue', 'gray', 'black'))+
    coord_cartesian(xlim = c(0, 1.1), ylim = c(0, 1.1))

plt1.2 <- cleaned_sim_same_mean |>
    ggplot()+
    geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type), size = 1)+
    theme_classic()+
    labs(x = 'Model 2 Error Variance',
         y = 'RMSE of Predictions',
         title = 'B. Full Graph')+
    scale_color_manual(values = c('orange', 'red', 'blue', 'cornflowerblue', 'gray', 'black'))



layout ="AAAB"
multiplt <- plt1.1 + plt1.2 +plot_layout(design = layout)
multiplt
```







