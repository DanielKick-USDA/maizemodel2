---
jupyter:
  jupytext:
    formats: 'ipynb,qmd'
  kernelspec:
    display_name: R
    language: R
    name: ir
---

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:03.882212Z', start_time: '2023-07-13T19:11:02.723Z'}
#| scrolled: true
library(drc)
library(tidyverse)
library(patchwork)
library(ggrepel)
library(ggrastr)
library(VCA)
ggplot2::theme_set(theme_minimal())
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:03.912344Z', start_time: '2023-07-13T19:11:02.729Z'}
overwrite_saved_files <- FALSE
```

# Figure 1

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:03.919933Z', start_time: '2023-07-13T19:11:02.733Z'}
fig1_ylim = c(0.825, 1.14)
#            Min                Max
#       Raw  0.857902419696555  1.13000518877101
# Ensembled  0.827244808392623  1.13000518877101
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:03.981436Z', start_time: '2023-07-13T19:11:02.737Z'}
Figure1_Data_1Mod <- read.csv("../output/Figure1_Data_1Mod.csv")
Figure1_Data_1Mod %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.012894Z', start_time: '2023-07-13T19:11:02.747Z'}
standardize_dat <- function(M){
    M <- M %>% 
      mutate(model = 
               case_when(
                model == "knn" ~ "KNN",
                model == "rf" ~ "RF",
                model == "rnr" ~ "RNR",
                model == "svrl" ~ "SVR",
                model == "DNN-Con." ~ "DNN-CO",
                model == "cat" ~ "DNN-CO",
                   
                model == "DNN-Sim." ~ "DNN-SO",                   
                model == "full" ~ "DNN-SO",

                model == "lm" ~ "LM",            

                model == "BLUP" ~ "BLUP",
                model == "bglr" ~ "BLUP",
                model == "Training Mean" ~ "Mean"
    ))

    # order the facets
    M$model <- factor(M$model, levels = c(
      "Mean", "LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO"))

    if(!('model_class' %in% names(M))){
        M <- M %>% 
          mutate(model_class = 
                   case_when(
                    model == "KNN" ~ "ML",
                    model == "RF" ~ "ML",
                    model == "RNR" ~ "ML",
                    model == "SVR" ~ "ML",
                    model == "DNN-CO" ~ "DNN",
                    model == "DNN-SO" ~ "DNN",

                    model == "LM" ~ "LM",            

                    model == "BLUP" ~ "BLUP",
                    model == "Mean" ~ "LM"
        ))        
    }
    
    M$model_class <- factor(M$model_class, levels = c("LM", "BLUP", "ML", "DNN"))
    # M$data_source <- factor(M$data_source, levels = c("G", "S", "W", "Multi"))
    return(M)    
}
Figure1_Data_1Mod <- standardize_dat(Figure1_Data_1Mod)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.020518Z', start_time: '2023-07-13T19:11:02.751Z'}
Figure1_Data_1Mod <- Figure1_Data_1Mod[!is.na(Figure1_Data_1Mod$model), ]
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.046488Z', start_time: '2023-07-13T19:11:02.755Z'}
fig1_orig_mods <- ggplot(Figure1_Data_1Mod, aes(model, test_rmse))+
    geom_boxplot(aes(fill = model_class))+
    scale_fill_brewer(type = "qual", palette = "Set2")+
    labs(y = '')+
    theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = 'none')+
    coord_cartesian(ylim = fig1_ylim)
# fig1_orig_mods
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.059016Z', start_time: '2023-07-13T19:11:02.760Z'}
temp <- read.csv("../output/Figure1_Data_Heatmap.csv")
# temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.297538Z', start_time: '2023-07-13T19:11:02.764Z'}
temp <- temp %>% 
    separate(Model1, c("model", "num"), "_") %>% 
    mutate(model = 
        case_when(
            model == "knn" ~ "KNN",
            model == "rf" ~ "RF",
            model == "rnr" ~ "RNR",
            model == "svrl" ~ "SVR",
            model == "cat" ~ "DNN-CO",
            model == "full" ~ "DNN-SO",

            model == "lm" ~ "LM",            

            model == "bglr" ~ "BLUP",
            model == "Training Mean" ~ "Mean" )) %>% 
#     mutate(model1 = model) %>% 
    unite(Model1, model:num,  sep = "_", remove = TRUE) %>% 
    separate(Model2, c("model", "num"), "_") %>% 
    mutate(model = 
        case_when(
            model == "knn" ~ "KNN",
            model == "rf" ~ "RF",
            model == "rnr" ~ "RNR",
            model == "svrl" ~ "SVR",
            model == "cat" ~ "DNN-CO",
            model == "full" ~ "DNN-SO",

            model == "lm" ~ "LM",            

            model == "bglr" ~ "BLUP",
            model == "Training Mean" ~ "Mean" )) %>% 
#     mutate(model2 = model) %>% 
    unite(Model2, model:num,  sep = "_", remove = TRUE)

# separate_wider_delim(Model1, "_", names = c("A", "B"))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.306892Z', start_time: '2023-07-13T19:11:02.769Z'}
mods <- c("Mean", "LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO")
reps <- 0:9
mod_reps <- paste(rep(mods, each = length(reps)),
                  rep(reps, time = length(mods)), sep = '_')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.315199Z', start_time: '2023-07-13T19:11:02.775Z'}
temp$Model1 <- factor(temp$Model1, levels = mod_reps)
temp$Model2 <- factor(temp$Model2, levels = mod_reps)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.346453Z', start_time: '2023-07-13T19:11:02.779Z'}
options(repr.plot.width=16, repr.plot.height=10)

add_lines_at = 0.5+(10*1:8)

fig1_heatmap <- ggplot(temp, aes(x = Model1, y = Model2, fill = RMSE))+
    geom_tile()+
    scale_fill_viridis_c()+
    coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = "on")+
    theme(axis.text.x = element_text(angle = 90, hjust = 1))+
    geom_hline(yintercept = add_lines_at, color = 'white')+
    geom_vline(xintercept = add_lines_at, color = 'white')
# fig1_heatmap 
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.454201Z', start_time: '2023-07-13T19:11:02.784Z'}
# are there any cases where a single model is better than all it's possible ensembles?
# diagonal < off

test_mod = 'LM_0'

single_mods <- unique(temp$Model1)

ens_pr_better <- map(single_mods, function(test_mod){
    single_mod_mask <- ((temp$Model1 == test_mod) & (temp$Model2 == test_mod))
    single_mod <- temp[single_mod_mask, 'RMSE']

    # only considering Model1 to 'shave' the matrix
    ens <- temp[(!single_mod_mask & (temp$Model1 == test_mod)) , ] 
    
    # % ens better
    return(mean(ens$RMSE < single_mod))    
}) %>% unlist()

ens_pr <- data.frame(single_mods, ens_pr_better)  %>% 
    mutate(ens_n_better = (79*ens_pr_better)) %>% 
    arrange(ens_pr_better)
ens_pr %>% head()
ens_pr %>% tail(n = 15)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.467530Z', start_time: '2023-07-13T19:11:02.789Z'}
# include table in supplement

ens_pr %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.483620Z', start_time: '2023-07-13T19:11:02.795Z'}
ens_pr['Model'] <- stringr::str_extract(ens_pr$single_mods, '\\D+') %>% stringr::str_remove('_')
ens_pr %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.509166Z', start_time: '2023-07-13T19:11:02.800Z'}
ens_pr %>% 
    summarise(
        ens_pr_better = mean(ens_pr_better),
        ens_n_better = mean(ens_n_better)
    )


# include table
ens_pr %>% 
    group_by(Model) %>% 
    summarise(
        ens_pr_better = mean(ens_pr_better),
        ens_n_better = mean(ens_n_better)
    ) %>% arrange(ens_pr_better)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.526254Z', start_time: '2023-07-13T19:11:02.804Z'}
temp['Model1'] <- stringr::str_extract(temp$Model1, '\\D+') %>% stringr::str_remove('_')
temp['Model2'] <- stringr::str_extract(temp$Model2, '\\D+') %>% stringr::str_remove('_')
temp['Models'] <- paste0(temp$Model1, '_', temp$Model2)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.539630Z', start_time: '2023-07-13T19:11:02.808Z'}
temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.571266Z', start_time: '2023-07-13T19:11:02.813Z'}
# set to same format as temp
Figure1_Data_1Mod_small <- Figure1_Data_1Mod %>% 
    rename(
        Models = model,
        RMSE = test_rmse) %>% 
    select(-data_source, #-model_class, 
           -replicate)

temp <- full_join(temp, Figure1_Data_1Mod_small)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.588147Z', start_time: '2023-07-13T19:11:02.817Z'}
# Deduplicate equivalent Models
out  <- list()
for(i in seq(1, length(mods))){
    for(j in seq(i, length(mods))){
        if(mods[i] == mods[j]){
            out[length(out)+1] <- mods[i]
        } else {
            out[length(out)+1] <- paste(mods[i], mods[j], sep = '_')
        }
    }
}
temp <- temp[temp$Models %in% out, ]
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:04.611213Z', start_time: '2023-07-13T19:11:02.822Z'}
temp <- temp %>% 
    group_by(Models) %>% 
    mutate(AveRMSE = mean(RMSE)) %>% 
    ungroup() %>% 
    arrange(AveRMSE)
temp$Models <- factor(temp$Models, levels = unique(temp$Models))
temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.154583Z', start_time: '2023-07-13T19:11:02.825Z'}
fig1_ens <- ggplot(temp, aes(Models, RMSE))+
    geom_boxplot(fill = 'lightgray', width=0.7)+
    geom_boxplot(data = Figure1_Data_1Mod_small, aes(fill = model_class, group = Models), width=0.7)+
    geom_boxplot(data = Figure1_Data_1Mod_small[Figure1_Data_1Mod_small$Models %in% c('KNN', 'RNR', 'RF'), ], color = '#8da0cb', width=0.7)+
    labs(x = "")+
    theme(axis.text.x = element_blank(), legend.position = 'none'
         )+
    coord_cartesian(ylim = fig1_ylim)+
    scale_fill_brewer(type = "qual", palette = "Set2")

fig1_ens
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.171005Z', start_time: '2023-07-13T19:11:02.835Z'}
temp$Model1_class <- case_when(
    temp$Model1 %in% c('LM') ~ 'LM',
    temp$Model1 %in% c('BLUP') ~ 'BLUP',
    temp$Model1 %in% c('KNN', 'RNR', 'RF', 'SVR') ~ 'ML',
    temp$Model1 %in% c('DNN-CO', 'DNN-SO') ~ 'DNN'
    )

temp$Model2_class <- case_when(
    temp$Model2 %in% c('LM') ~ 'LM',
    temp$Model2 %in% c('BLUP') ~ 'BLUP',
    temp$Model2 %in% c('KNN', 'RNR', 'RF', 'SVR') ~ 'ML',
    temp$Model2 %in% c('DNN-CO', 'DNN-SO') ~ 'DNN'
    )
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.187063Z', start_time: '2023-07-13T19:11:02.839Z'}
# if there's only one model (not ensembled) then it should be filled in for plotting
temp[is.na(temp$Model1), 'Model1_class'] <- temp[is.na(temp$Model1), 'model_class']
temp[is.na(temp$Model1), 'Model1'] <- temp[is.na(temp$Model1), 'Models']

temp[is.na(temp$Model2), 'Model2_class'] <- temp[is.na(temp$Model2), 'model_class']
temp[is.na(temp$Model2), 'Model2'] <- temp[is.na(temp$Model2), 'Models']
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.195148Z', start_time: '2023-07-13T19:11:02.843Z'}
temp$Model1_class <- factor(temp$Model1_class, levels = c("LM", "BLUP", "ML", "DNN"))
temp$Model2_class <- factor(temp$Model2_class, levels = c("LM", "BLUP", "ML", "DNN"))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.202225Z', start_time: '2023-07-13T19:11:02.848Z'}
temp$Model1 <- factor(temp$Model1, levels = c("LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO"))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.216463Z', start_time: '2023-07-13T19:11:02.852Z'}
fig1_ens_members <- ggplot(temp, aes(x = Models))+
    geom_tile(aes(y = Model1, fill = Model1_class))+
    geom_tile(aes(y = Model2, fill = Model2_class))+
    # Add in fake grid
    geom_vline(xintercept = 0.5+1:35, color = 'gray')+
    geom_hline(yintercept = 0.5+1:7, color = 'gray')+
    labs(x = 'Models Combinations', y = 'Models')+
    scale_fill_brewer(type = "qual", palette = "Set2")+
    theme(axis.text.x = element_text(angle = 90, hjust = 1), legend.position = 'none',
          panel.grid.major = element_blank(), panel.grid.minor = element_blank())
# fig1_ens_members
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.849947Z', start_time: '2023-07-13T19:11:02.861Z'}
layout <- "
A
A
A
A
B
"
options(repr.plot.width=16, repr.plot.height=10)

stacked_fig <- (fig1_ens+fig1_ens_members)+plot_layout(design = layout)
stacked_fig
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:05.857457Z', start_time: '2023-07-13T19:11:02.864Z'}
if(overwrite_saved_files == TRUE){
    ggsave(stacked_fig, filename = './boxplot_2mods.svg', width = 16, height = 10)
    ggsave(stacked_fig, filename = './boxplot_2mods.pdf', width = 16, height = 10)    
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.135256Z', start_time: '2023-07-13T19:11:02.869Z'}
fig1_heatmap
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.142872Z', start_time: '2023-07-13T19:11:02.873Z'}
if(overwrite_saved_files == TRUE){
    ggsave(fig1_heatmap, filename = './heatmap_2mods.svg', width = 10, height = 10)
    ggsave(fig1_heatmap, filename = './heatmap_2mods.pdf', width = 10, height = 10)
}
```

# Supplementary Figure 1 (Redo)

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.507743Z', start_time: '2023-07-13T19:11:02.914Z'}
temp <- read.csv("../output/SFigure1_Data_RMSE_Ens_SelectMods_redo.csv")


temp <- temp %>% 
    rename(model = Model1) %>% 
    mutate(model = 
        case_when(
            model == "knn" ~ "KNN",
            model == "rf" ~ "RF",
            model == "rnr" ~ "RNR",
            model == "svrl" ~ "SVR",
            model == "cat" ~ "DNN-CO",
            model == "full" ~ "DNN-SO",

            model == "lm" ~ "LM",            

            model == "bglr" ~ "BLUP",
            model == "Training Mean" ~ "Mean" )) %>% 
    rename(Model1 = model) %>% 
    rename(model = Model2) %>% 
    mutate(model = 
        case_when(
            model == "knn" ~ "KNN",
            model == "rf" ~ "RF",
            model == "rnr" ~ "RNR",
            model == "svrl" ~ "SVR",
            model == "cat" ~ "DNN-CO",
            model == "full" ~ "DNN-SO",

            model == "lm" ~ "LM",            

            model == "bglr" ~ "BLUP",
            model == "Training Mean" ~ "Mean" )) %>% 
    rename(Model2 = model)

temp$Model1 <- factor(temp$Model1, levels = c("LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO"))
temp$Model2 <- factor(temp$Model2, levels = c("LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO"))

# temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.514534Z', start_time: '2023-07-13T19:11:02.919Z'}
# temp %>% group_by(Model1, Model2, n_mods) %>% tally()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.524630Z', start_time: '2023-07-13T19:11:02.924Z'}
temp$Model1 %>% unique
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.582149Z', start_time: '2023-07-13T19:11:02.928Z'}
# duplicate to make tidy wrt model1/model2
temp2 <- temp %>% 
    rename(Model3 = Model1) %>% 
    rename(Model1 = Model2) %>% 
    rename(Model2 = Model3)
# drop where Model1==Model2; that's already in temp
temp2 <- temp2[(temp2$Model1 != temp2$Model2), ]

temp <- full_join(temp, temp2)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.619352Z', start_time: '2023-07-13T19:11:02.933Z'}
# Quick check that all groups have the same number of observations:
temp %>% 
    group_by(Model1, Model2, ensemble, n_mods) %>% 
    tally()  %>% 
    ungroup() %>% 
    select(n) %>% 
    distinct()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:06.632554Z', start_time: '2023-07-13T19:11:02.938Z'}
temp %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.798330Z', start_time: '2023-07-13T19:11:02.942Z'}
# quick vis --are trends captured by EXD and linear models?

ggplot(temp, aes(n_mods, rmse, color = Model2))+
    geom_smooth()+
    facet_grid(ensemble ~ Model1)

```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.808800Z', start_time: '2023-07-13T19:11:02.947Z'}
unique(temp$Model1)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.843007Z', start_time: '2023-07-13T19:11:02.951Z'}
# what is the rmse at n=10 for each set?

temp |> 
    filter(n_mods == 10) |> 
    group_by(ensemble, Model1, Model2, n_mods) |> 
    summarise('rmse'=mean(rmse)) |> 
    ungroup() |>
    select(-n_mods) |> 
    pivot_wider(id_cols = c('Model1', 'Model2'), values_from = 'rmse', names_from = 'ensemble') |>
    write.csv('../output/0000_possible_additional_table.csv')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.879037Z', start_time: '2023-07-13T19:11:02.974Z'}
# Extend to multiple 
fit_exd_for_model <- function(target_model = 'BLUP', ensemble_type = '', sd_threshold = 1e-10
){
    print(paste0("Comparing Performance: ", target_model))

    dat <- temp
    dat <- dat[(dat$ensemble == ensemble_type), ]
    dat <- dat[(dat$Model1 == target_model | dat$Model2 == target_model), ]
    dat$Comparison <- dat$Model1
    dat[dat$Model1 == target_model, 'Comparison'] <- dat[dat$Model1 == target_model, 'Model2']

    
    
#     dat <- temp[(((temp$Model1 == target_model) | (temp$Model2 == target_model)
#                 ) & (temp$ensemble == ensemble_type)), ]
#     dat$Comparison <- dat$Model1
#     # Don't need to find special case where both are target model because this 
#     # will only overwrite cases where that is not the case
#     dat[dat$Model1 == target_model, 'Comparison'] <- dat[dat$Model1 == target_model, 'Model2']

#     dat <- mutate(dat, Comparison = as.character(Comparison)) # explicitly setting comparison to chr instead of factor
    
    # allows for correct leveling if a group is dropped.

    check_sd <- dat %>% 
                group_by(Model1, Model2) %>% 
                summarise(sd = sd(rmse))


    if(nrow(check_sd[check_sd$sd <= sd_threshold, ]) == 0){
        fm = drm(rmse ~ n_mods, 
                 data = left_join(select(check_sd[check_sd$sd > sd_threshold, ], -sd), dat), 
                 Comparison,
               # fct = AR.3() # up and saturate
                 fct = EXD.3(), # exponential decay
                 #  f(x) = c + (d − c)(exp(−x/e))
                 #  (c, d, e)
                 pmodels = list(
                     ~factor(Comparison), # y at t=inf
                     ~factor(Comparison), # rate
                     ~1
                 ) 
                )

        Comparison_ok_sd <- unlist(unique(select(ungroup(left_join(select(
            check_sd[check_sd$sd > 0, ], -sd), dat)), Comparison)))

        # make prediction df
        predict_df <- expand.grid(
            rmse = NA,
            n_mods = seq(min(dat$n_mods), max(dat$n_mods)),
            Comparison = Comparison_ok_sd    
        )

        predict_df$fit <- "EXD3"

        predict_df$rmse <- predict(fm, newdata = predict_df)



    } else {
        exd_dat <- left_join(select(check_sd[check_sd$sd > sd_threshold, ], -sd), dat)
        fm = drm(rmse ~ n_mods, 
                 data = exd_dat,  
                 Comparison,
               # fct = AR.3() # up and saturate
                 fct = EXD.3(), # exponential decay
                 #  f(x) = c + (d − c)(exp(−x/e))
                 #  (c, d, e)
                 pmodels = list(
                     ~factor(Comparison), # y at t=inf
                     ~factor(Comparison), # rate
                     ~1
                 ) 
                )

        fm_linear = lm(rmse ~ n_mods, 
                       data = left_join(select(check_sd[check_sd$sd <= sd_threshold, ], -sd), dat))


        Comparison_ok_sd <- unlist(unique(select(ungroup(left_join(select(
            check_sd[check_sd$sd > sd_threshold, ], -sd), dat)), Comparison)))

        Comparison_0sd <- unlist(unique(select(ungroup(left_join(select(
            check_sd[check_sd$sd <= sd_threshold, ], -sd), dat)), Comparison)))

        # make prediction df
        predict_df <- expand.grid(
            rmse = NA,
            n_mods = seq(min(dat$n_mods), max(dat$n_mods)),
            Comparison = Comparison_ok_sd    
        )

        predict_df_0sd <- expand.grid(
            rmse = NA,
            n_mods = seq(min(dat$n_mods), max(dat$n_mods)),
            Comparison = Comparison_0sd    
        )

        predict_df$fit <- "EXD3"
        predict_df_0sd$fit <- "Linear"

        predict_df$rmse <- predict(fm, newdata = predict_df)
        predict_df_0sd$rmse <- predict(fm_linear, newdata = predict_df_0sd)

        predict_df <- rbind(predict_df, predict_df_0sd)

    }

    # Apply grouping colors to match above
    predict_df$Comparison_class <- case_when(
        predict_df$Comparison %in% c('LM') ~ 'LM',
        predict_df$Comparison %in% c('BLUP') ~ 'BLUP',
        predict_df$Comparison %in% c('KNN', 'RNR', 'RF', 'SVR') ~ 'ML',
        predict_df$Comparison %in% c('DNN-CO', 'DNN-SO') ~ 'DNN'
        )

    predict_df[is.na(predict_df$Comparison), 'Comparison_class'] <- predict_df[is.na(predict_df$Comparison), 'model_class']
    predict_df[is.na(predict_df$Comparison), 'Comparison'] <- predict_df[is.na(predict_df$Comparison), 'Models']

    predict_df$Comparison_class <- factor(predict_df$Comparison_class, levels = c("LM", "BLUP", "ML", "DNN"))

    return(list(
        predict_df = predict_df,
        fm = fm
    ))
}


plot_exd_for_model <- function(res, set_linesize = 1, set_linealpha = 0.5){
    predict_df <- res$predict_df
    
    mask_linetype1 = !(predict_df$Comparison %in% c("RF", "RNR", "SVR", "DNN-SO"))
    mask_linetype2 =  (predict_df$Comparison %in% c("RF","DNN-SO"))
    mask_linetype3 =  (predict_df$Comparison %in% c("RNR"))
    mask_linetype4 =  (predict_df$Comparison %in% c("SVR"))

    plt <- ggplot(predict_df, aes(x = n_mods, y = rmse, color  = Comparison_class, group = Comparison))+
        geom_line(data = predict_df[mask_linetype1, ], linewidth = set_linesize, alpha = set_linealpha )+
        geom_line(data = predict_df[mask_linetype2, ], linewidth = set_linesize, linetype = 'longdash', alpha = set_linealpha)+
        geom_line(data = predict_df[mask_linetype3, ], linewidth = set_linesize, linetype = 'dashed', alpha = set_linealpha )+
        geom_line(data = predict_df[mask_linetype4, ], linewidth = set_linesize, linetype = 'dotdash', alpha = set_linealpha)+
        ggrepel::geom_label_repel(data =predict_df[predict_df$n_mods == max(predict_df$n_mods), ], 
                                  aes(label = Comparison, fill = Comparison_class), 
                                  color = "black", 
                                  nudge_x = length(unique(predict_df$n_mods))/20)+
#                                   nudge_x = length(unique(predict_df$n_mods))/5)+
        scale_color_brewer(type = "qual", palette = "Set2")+
        scale_fill_brewer(type = "qual", palette = "Set2")+
        theme(legend.position = "None")+
        labs(x = "Number of Models", y = "RMSE")    
    return(plt)
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.892886Z', start_time: '2023-07-13T19:11:02.977Z'}
mod_names <- c("LM", "BLUP", "KNN", "RNR", "RF", "SVR", "DNN-CO", "DNN-SO")
ensemble_types <- c('uniform_weights', 'uniform_by_type_weights', 'inv_std_weights', 
        'inv_var_weights', 'inv_rmse_weights')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.932730Z', start_time: '2023-07-13T19:11:03.023Z'}
# Because this takes a long time to run (est ~ 1hr) I'm splitting it up and saving out multiple data objects
# this way any debugging can be done piecemeal

# mod_names
for(ensemble_type in ensemble_types){
    save_path <- paste0("./res_list_ENS_",ensemble_type,".RDS")

    if(!file.exists(save_path)){
        print(paste('Trying', ensemble_type))
        res_list <- map(mod_names, function(e){
            fit_exd_for_model(
                target_model = e, 
                ensemble_type = ensemble_type,
                sd_threshold = 1e-3)
        })
        saveRDS(res_list, save_path)
    }
}


```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:10.948053Z', start_time: '2023-07-13T19:11:03.033Z'}
mk_ensemble_composite_figure <- function(
    ensemble_type = 'uniform_weights',
    figure_y_min = 0, 
    figure_y_max = 10
){
    # Make individual two model trend plots
    res_list = readRDS( paste0("./res_list_ENS_",ensemble_type,".RDS"))

    res_plt_list <- map(res_list, function(e){
        plot_exd_for_model(res = e, set_linesize = 1, set_linealpha = 0.75)})

    # Pull in and work with ensemble using ANY models --------------------------
    if (TRUE){
        temp_all <- read.csv("../output/SFigure1_Data_RMSE_Ens_Any_n_Mods_redo.csv")

        temp_all <- temp_all[temp_all$ensemble == ensemble_type, ]
        # make prediction df
        predict_df <- expand.grid(
            n_mods = seq(min(temp_all$n_mods), max(temp_all$n_mods))
        )

        fm = drm(rmse ~ n_mods, 
                 data = temp_all, 
                 fct = EXD.3(), # exponential decay
                 #  f(x) = c + (d − c)(exp(−x/e))
                 #  (c, d, e)
                 pmodels = list(
                     ~1, # y at t=inf
                     ~1, # rate
                     ~1) )

        predict_df <- cbind(predict_df, 
                            rename(data.frame(predict(fm, 
                                                      newdata = predict_df, se.fit = TRUE)), 
                                   rmse = Prediction))

        sfig1_ens_mods_any <- ggplot(temp_all, aes(x = n_mods, y = rmse))+
            geom_point(color = 'black', alpha = 0.3)+
            geom_line(data = predict_df, color = '#ffd92f', linewidth = 1)+
            scale_x_continuous(breaks= seq(0, 80, 10))+
            labs(x = 'Number of Models', y = 'RMSE')+
            coord_cartesian(y = c(figure_y_min, figure_y_max))+
            theme(panel.grid.minor = element_blank())    
    }
    
    # Pull in and work with ensemble using all data --------------------------
    if (TRUE){
        temp_all <- read.csv("../output/SFigure1_Data_RMSE_Ens_AllMods_redo.csv")

        temp_all <- temp_all[temp_all$ensemble == ensemble_type, ]
        # make prediction df
        predict_df <- expand.grid(
            n_mods = seq(min(temp_all$n_mods), max(temp_all$n_mods))
        )

        fm = drm(rmse ~ n_mods, 
                 data = temp_all, 
                 fct = EXD.3(), # exponential decay
                 #  f(x) = c + (d − c)(exp(−x/e))
                 #  (c, d, e)
                 pmodels = list(
                     ~1, # y at t=inf
                     ~1, # rate
                     ~1) )

        predict_df <- cbind(predict_df, 
                            rename(data.frame(predict(fm, 
                                                      newdata = predict_df, se.fit = TRUE)), 
                                   rmse = Prediction))

        sfig1_ens_mods <- ggplot(temp_all, aes(x = n_mods, y = rmse))+
            geom_point(color = 'black', alpha = 0.3)+
            geom_line(data = predict_df, color = '#a6d854', linewidth = 1)+
            scale_x_continuous(breaks=c(0, 5, 10))+
            labs(x = 'Number of Models', y = 'RMSE')+
            coord_cartesian(x = c(0, 10),
                            y = c(figure_y_min, figure_y_max))+
            theme(panel.grid.minor = element_blank())    
    }
    
    
    
    
    

    # enforce matching limits
    res_plt_list <- map(res_plt_list, function(e){
        return(
            e+scale_x_continuous(breaks=c(0, 5, 10))+
            theme(panel.grid.minor = element_blank())+
            coord_cartesian(x = c(0, 10),
                            y = c(figure_y_min, figure_y_max))
    #         e+lims(y = c(min(temp$rmse), max(temp$rmse) )) 
    #         e+coord_cartesian(y = c(0.83, 1.3))+geom_hline(yintercept = 0.889879972458087) 
              )
    })

    

    multi_plt <- (
        sfig1_ens_mods_any+ggtitle(     paste0(LETTERS[1], '. ', 'Any Model'))+
           sfig1_ens_mods+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[1+1], '. ', 'Every Model'))+
        res_plt_list[[1]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[2+1], '. ', mod_names[1]))+
        res_plt_list[[2]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[3+1], '. ', mod_names[2]))+
        res_plt_list[[3]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[4+1], '. ', mod_names[3]))+
        res_plt_list[[4]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[5+1], '. ', mod_names[4]))+
        res_plt_list[[5]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[6+1], '. ', mod_names[5]))+
        res_plt_list[[6]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[7+1], '. ', mod_names[6]))+
        res_plt_list[[7]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[8+1], '. ', mod_names[7]))+
        res_plt_list[[8]]+labs(y = '')+theme(axis.text.y = element_blank())+ggtitle(paste0(LETTERS[9+1], '. ', mod_names[8])
    )+plot_layout(
        widths = c(2, 1,
                   1, 1, 1, 1, 1, 1, 1, 1)
    )
)
    return(multi_plt)
}

```


```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:14.992433Z', start_time: '2023-07-13T19:11:03.041Z'}
multi_plt <- mk_ensemble_composite_figure(
    ensemble_type = 'uniform_weights',
    figure_y_min = 0.84, 
    figure_y_max = 1.15)

if(overwrite_saved_files == TRUE){
    ggsave(multi_plt, filename = './ExponentialDecay_uniform_weights.svg', width = 20, height = 10)
}
multi_plt
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:16.282215Z', start_time: '2023-07-13T19:11:03.047Z'}
multi_plt <- mk_ensemble_composite_figure(
    ensemble_type = 'uniform_by_type_weights',
    figure_y_min = 0.84, 
    figure_y_max = 1.15)

if(overwrite_saved_files == TRUE){
    ggsave(multi_plt, filename = './ExponentialDecay_uniform_by_type_weights.svg', width = 20, height = 10)
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:17.233341Z', start_time: '2023-07-13T19:11:03.050Z'}
multi_plt <- mk_ensemble_composite_figure(
    ensemble_type = 'inv_std_weights',
    figure_y_min = 0.84, 
    figure_y_max = 1.15)
    
if(overwrite_saved_files == TRUE){
    ggsave(multi_plt, filename = './ExponentialDecay_inv_std_weights.svg', width = 20, height = 10)
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:18.167345Z', start_time: '2023-07-13T19:11:03.056Z'}
multi_plt <- mk_ensemble_composite_figure(
    ensemble_type = 'inv_var_weights',
    figure_y_min = 0.84, 
    figure_y_max = 1.15)
    
if(overwrite_saved_files == TRUE){
    ggsave(multi_plt, filename = './ExponentialDecay_inv_var_weights.svg', width = 20, height = 10)
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:19.068240Z', start_time: '2023-07-13T19:11:03.060Z'}
multi_plt <- mk_ensemble_composite_figure(
    ensemble_type = 'inv_rmse_weights',
    figure_y_min = 0.84, 
    figure_y_max = 1.15)
    
if(overwrite_saved_files == TRUE){
    ggsave(multi_plt, filename = './ExponentialDecay_inv_rmse_weights.svg', width = 20, height = 10)
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:21.710341Z', start_time: '2023-07-13T19:11:03.067Z'}
# make a summary table of the predicted values of each mix
mod_fit_table <- do.call(
    rbind, 
    map(ensemble_types, 
        function(ensemble_type){
            res_list = readRDS( paste0("./res_list_ENS_",ensemble_type,".RDS"))

            do.call(rbind, 
                    map(seq_along(res_list), 
                        function(i){
                            res <- res_list[[i]]
                            temp <- filter(res$predict_df, n_mods == 10)
                            temp['Model1'] <- mod_names[i]
                            temp['Ensemble'] <- ensemble_type
                            temp <- temp %>% rename(RMSE = rmse, Model2 = Comparison, Fit = fit)
                            temp <- temp[, c('Ensemble', 'Model1', 'Model2', 'Fit', 'RMSE')]
                            return(temp)    
                        }
                       )
                   )
        }
       )
)

if(overwrite_saved_files == TRUE){
    write.csv(mod_fit_table, './ExponentialDecay_fit_summary_long.csv')
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:21.725526Z', start_time: '2023-07-13T19:11:03.071Z'}
mod_fit_table_wide <- mod_fit_table %>% 
    select(-Fit) %>% 
    pivot_wider(
      names_from = Ensemble,
      values_from = RMSE
)

if(overwrite_saved_files == TRUE){
    write.csv(mod_fit_table_wide, './ExponentialDecay_fit_summary_wide.csv')
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:21.736622Z', start_time: '2023-07-13T19:11:03.076Z'}
ensemble_types
mod_names
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:21.750024Z', start_time: '2023-07-13T19:11:03.079Z'}
mod_fit_table %>% head()
```

# Understanding Performance

## Load Data

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.039035Z', start_time: '2023-07-13T19:11:03.098Z'}
ModTrain <- read.csv('../output/01_mod_train.csv') %>% select(-'X')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.242124Z', start_time: '2023-07-13T19:11:03.102Z'}
ModTest <- read.csv('../output/01_mod_test.csv') %>% select(-'X')
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.259471Z', start_time: '2023-07-13T19:11:03.108Z'}
ModWeights <- read.csv('../output/01_mod_weights.csv') %>% select(-'X')
ModWeights  %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.276656Z', start_time: '2023-07-13T19:11:03.114Z'}
ModWeightsTest <- read.csv('../output/01_mod_weights_test.csv') %>% select(-'X')
ModWeightsTest  %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.445877Z', start_time: '2023-07-13T19:11:03.119Z'}
# Allow for easy renaming of columns from (e.g.) bglr_0 to BLUP_0

replacement_names <- data.frame(all_mod_cols = names(ModTrain)) |> 
    mutate(model = str_remove(all_mod_cols, '_\\d' )) |> 
    mutate(model_num = str_remove(all_mod_cols, '\\D+_' )) |> 
    standardize_dat() |>
    mutate(model_num = paste0(model, '_', model_num)) |>
    select(all_mod_cols, model_num) |>
    filter(!(all_mod_cols %in% c(
    'Pedigree',
    'F',
    'M',
    'ExperimentCode',
    'Year',
    'y' 
    ))) |>
    rename(old_name = all_mod_cols, new_name = model_num)

replacement_names |> head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.462210Z', start_time: '2023-07-13T19:11:03.123Z'}
# update names
names(ModTrain) <- map(names(ModTrain), function(e){
    out <- e
    if(e %in% replacement_names$old_name){out <- replacement_names[replacement_names$old_name == e, 'new_name']}
    return(out) })

names(ModTest) <- map(names(ModTest), function(e){
    out <- e
    if(e %in% replacement_names$old_name){out <- replacement_names[replacement_names$old_name == e, 'new_name']}
    return(out) })
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.483281Z', start_time: '2023-07-13T19:11:03.127Z'}
ModWeights <- ModWeights |> 
    mutate(model = str_remove(all_mod_cols, '_\\d' )) |> 
    mutate(model_num = str_remove(all_mod_cols, '\\D+_' )) |> 
    standardize_dat() |>
    mutate(model_num = paste0(model, '_', model_num))
ModWeights |> head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:24.495567Z', start_time: '2023-07-13T19:11:03.132Z'}
ModWeightsTest <- ModWeightsTest |> 
    mutate(model = str_remove(all_mod_cols, '_\\d' )) |> 
    mutate(model_num = str_remove(all_mod_cols, '\\D+_' )) |> 
    standardize_dat() |>
    mutate(model_num = paste0(model, '_', model_num))
```

## Variance Component Analysis

### Making similar output to `varPlot` that works for data scale

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:25.030571Z', start_time: '2023-07-13T19:11:03.278Z'}
ModAllPlt <- rbind(mutate(ModTrain, Set = 'Train'), 
                mutate(ModTest, Set = 'Test')) |>
        select(Pedigree, ExperimentCode, Year, Set, y) |>
        unite(SiteYear, ExperimentCode:Year)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:11:25.057928Z', start_time: '2023-07-13T19:11:03.282Z'}
# only for ease of plot ordering later.
first.SiteYears <- ModAllPlt %>% filter(Set == 'Train')  %>% select(SiteYear)  %>% distinct()  %>% unlist()  %>% sort()
last.SiteYears <- ModAllPlt %>% filter(Set == 'Test')  %>% select(SiteYear)  %>% distinct()  %>% unlist()  %>% sort()


ModAllPlt$Set <- as.factor(ModAllPlt$Set)
ModAllPlt$SiteYear <- factor(ModAllPlt$SiteYear, levels = c(first.SiteYears, last.SiteYears))
ModAllPlt$Pedigree <- as.factor(ModAllPlt$Pedigree)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:34.796739Z', start_time: '2023-07-13T19:11:03.294Z'}
outPlt <-varPlot(form=y~Set/SiteYear/Pedigree, Data=ModAllPlt, 
       MeanLine=list(var=c("ExperimentCode", "Set"), 
                      col=c("cyan", "magenta"), lwd=c(2))
       )
head(outPlt)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:34.814390Z', start_time: '2023-07-13T19:11:03.299Z'}
outPlt <- outPlt |> arrange(desc(Set), SiteYear, Pedigree) |> select(-Xcoord)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:34.850311Z', start_time: '2023-07-13T19:11:03.304Z'}
outPltXcoord <- distinct(outPlt[, c('Pedigree', 'SiteYear')])
outPltXcoord$Xcoord <- seq(1, nrow(outPltXcoord))
outPlt <- full_join(outPlt, outPltXcoord)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:35.406506Z', start_time: '2023-07-13T19:11:03.309Z'}
outPlt |> head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.461460Z', start_time: '2023-07-13T19:11:03.314Z'}
# Alternative to point plot: Sd bars

outPlt.pos.sd.siteyeargeno <- outPlt |> 
    as.tibble() |> 
    group_by(SiteYear, Pedigree) |> 
    summarise(
        x = min(Xcoord),
        ymeanPsd = mean(y)+(0.5*sd(y)),
        ymeanMsd = mean(y)-(0.5*sd(y)),
        ymean = mean(y)
    ) |> ungroup()

outPlt.pos.sd.siteyeargeno %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.477432Z', start_time: '2023-07-13T19:11:03.320Z'}
outPlt.pos.lables.SiteYear <- outPlt |> 
    group_by(SiteYear) |>
    summarise(xMin = min(Xcoord),
              xMax = max(Xcoord),
              xMean = mean(Xcoord)
             ) |> ungroup()

outPlt.pos.lables.Set <- outPlt |> 
    group_by(Set) |>
    summarise(xMin = min(Xcoord),
              xMax = max(Xcoord),
              xMean = mean(Xcoord)
             ) |> ungroup()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.489163Z', start_time: '2023-07-13T19:11:03.324Z'}
outPlt.pos.lables.Set
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.501365Z', start_time: '2023-07-13T19:11:03.328Z'}
outPlt.pos.train <- outPlt |> filter(Set == 'Train') |> summarise(
    x = min(Xcoord),
    xend = max(Xcoord),
    xmean = mean(Xcoord)
)

outPlt.pos.test <- outPlt |> filter(Set == 'Test') |> summarise(
    x = min(Xcoord),
    xend = max(Xcoord),
    xmean = mean(Xcoord)
)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.529740Z', start_time: '2023-07-13T19:11:03.333Z'}
outPlt.pos.meanlines.siteyear <- outPlt |> 
    as.tibble() |> 
    group_by(Set, SiteYear) |> 
    summarise(
        x = min(Xcoord),
        xend = max(Xcoord),
        xmean = mean(Xcoord),
        ymean = mean(y)
    ) |> ungroup()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.581957Z', start_time: '2023-07-13T19:11:03.340Z'}
outPlt.pos.meanlines.site <- outPlt |> 
    mutate(Site = as.character(SiteYear)) |> 
    mutate(Site = str_remove(Site, pattern = "_\\d+")) |> 
    as.tibble() |> 
    mutate(Set = as.character(Set)) |>
    group_by(Set, Site) |> 
    summarise(
        x = min(Xcoord),
        xend = max(Xcoord),
        xmean = mean(Xcoord),
        ymean = mean(y)
    ) |> ungroup()

outPlt.pos.meanlines.site %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.607555Z', start_time: '2023-07-13T19:11:03.347Z'}
# for vertical lines between site mean and siteyear mean

t1 <- (outPlt.pos.meanlines.siteyear |> 
     mutate(
         SiteYear = as.character(SiteYear),
         Site = as.character(SiteYear)) |> 
    mutate(Site = str_remove(Site, pattern = "_\\d+")))
# filter(Site == "IAH3")

# t1 |> filter(SiteYear == "IAH3_2014")

t2 <- (rename(outPlt.pos.meanlines.site,
          ymean.site = ymean) |> 
     select(Set, Site, ymean.site))
# t2 |> filter(Site == "IAH3")

outPlt.pos.vlines.sitesiteyear <- full_join(t1, t2) 
# outPlt.pos.vlines.sitesiteyear |> filter(Site == "IAH3")
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:36.621063Z', start_time: '2023-07-13T19:11:03.353Z'}
outPlt.pos.meanlines.site %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:37.683778Z', start_time: '2023-07-13T19:11:03.359Z'}
bar.pos.y = -4.25 # y max is 4.09466474615452
bar.pos.siteyear = -3 # y min is -2.89449085652765

variability_chart <- ggplot()+
    # Train / Test -----------------------------------------------------------
    geom_segment(data = outPlt.pos.train, aes(x = xend, xend = xend, y = bar.pos.y, yend = 4), color = 'black')+
    # hlines/labels
#     geom_segment(data = outPlt.pos.train, aes(x = x, xend = xend, y = bar.pos.y, yend = bar.pos.y), color = 'blue')+
    geom_label(data = outPlt.pos.train, aes(x = xmean, y = bar.pos.y, label = 'Train'))+
#     geom_segment(data = outPlt.pos.test, aes(x = x, xend = xend, y = bar.pos.y, yend = bar.pos.y), color = 'red')+
    geom_label(data = outPlt.pos.test, aes(x = xmean, y = bar.pos.y, label = 'Test'))+

    # Observations -----------------------------------------------------------
    geom_point(data = outPlt, aes(Xcoord, y), size = 0.1, color = 'gray')+ # raw values
#     geom_point(data = outPlt.pos.sd.siteyeargeno,
#                aes(x, ymean), size = 0.1, color = 'gray')+
#     geom_segment(data = outPlt.pos.sd.siteyeargeno[!is.na(outPlt.pos.sd.siteyeargeno$ymeanPsd), ],
#                aes(x=x, xend=x, y=ymeanMsd, yend=ymeanPsd), size = 0.1, color = 'gray')+

    # Residual Env to SiteYear ---------------------------------------------------
    geom_segment(data = outPlt.pos.vlines.sitesiteyear , 
                 aes(x = xmean, xend = xmean, y = ymean, yend = ymean.site), color = 'cornflowerblue', size = 1)+
    # SiteYear Means --------------------------------------------------------------
    geom_segment(data = outPlt.pos.meanlines.siteyear, aes(x = x, xend = xend, y = ymean, yend = ymean), color = 'red', size = 1)+
    # Site Means -------------------------------------------------------------
    geom_segment(data = outPlt.pos.meanlines.site , aes(x = x, xend = xend, y = ymean, yend = ymean), color = 'red', size = 1)+
    # x "axis"
    geom_text(data = outPlt.pos.meanlines.siteyear, aes(x = xmean, y = bar.pos.siteyear, label = SiteYear), angle = 90, hjust = 1)+
    labs(y = 'Normalize Yield')+    
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.major.y = element_line(colour = 'darkgray'),
          panel.grid.minor.x = element_blank(),
          panel.grid.minor.y = element_line(colour = 'darkgray')
         )+
    coord_cartesian(ylim = c(bar.pos.y, 4))
    
variability_chart
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:37.832266Z', start_time: '2023-07-13T19:11:03.364Z'}
outPltAnnotated <- outPlt |> 
    mutate(Site = as.character(SiteYear)) |> 
    mutate(Site = str_remove(Site, pattern = "_\\d+")) |>
    group_by(Set, Site) |>
    mutate(yMeanSite = mean(y)) |>
    ungroup() |>
    group_by(Set, SiteYear) |>
    mutate(yMeanSiteYear = mean(y)) |>
    ungroup() 

# Figure out x position for
## points
outPltAnnotated <- outPltAnnotated |>
    mutate(Set = factor(Set, levels = c('Train', 'Test'))) |>
    group_by(Set) |>
    arrange(Set, yMeanSite, SiteYear, Pedigree) |>
    ungroup()

outPltAnnotated$Xcoord <- 1:nrow(outPltAnnotated)

## group stats
outPltAnnotated <- outPltAnnotated |>
    group_by(Set) |>
    mutate(xMinSet= min(Xcoord),
           xMeanSet =mean(Xcoord),
           xMaxSet= max(Xcoord)) |>
    ungroup() |>
    group_by(Set, Site) |>
    mutate(xMinSite = min(Xcoord),
           xMeanSite =mean(Xcoord),
           xMaxSite = max(Xcoord)) |>
    ungroup() |>
    group_by(Set, SiteYear) |>
    mutate(xMinSiteYear = min(Xcoord),
           xMeanSiteYear =mean(Xcoord),
           xMaxSiteYear = max(Xcoord)) |>
    ungroup() 

## Move Pedigree's to the same Xcoord
outPltAnnotated <- outPltAnnotated |>
    group_by(Set, SiteYear, Pedigree) |>
    mutate(Xcoord = min(Xcoord)) |>
    ungroup() 


outPltAnnotated %>% head()
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:37.858809Z', start_time: '2023-07-13T19:11:03.373Z'}
# Deduplicated versions to prevent drawing multiple identical objects
outPltAnnotated.Set <- outPltAnnotated |> select(ends_with('Set')) |> distinct()
outPltAnnotated.Site <- outPltAnnotated |> select(ends_with('Site')) |> distinct()
outPltAnnotated.SiteYear <- outPltAnnotated |> select(ends_with('Year')) |> distinct()

# add in year only col
outPltAnnotated.SiteYear <- outPltAnnotated.SiteYear |> 
    mutate(Year = as.character(SiteYear)) |> 
    mutate(Year = str_remove(Year, pattern = '^.*_'))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:37.867176Z', start_time: '2023-07-13T19:11:03.377Z'}
# to alternate colors on labels
outPltAnnotated.Site$everyOtherSite <- rep(c('a', 'b'), times = ceiling(nrow(outPltAnnotated.Site)/2))[1:nrow(outPltAnnotated.Site)]
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:45.405845Z', start_time: '2023-07-13T19:11:03.381Z'}

# rasterized for easier post processing in inkscape 
use_dpi = 300

variability_chart <- ggplot(outPltAnnotated)+
    # Train / Test -----------------------------------------------------------
    geom_segment(data = outPltAnnotated.Set, aes(x = xMinSet, xend = xMaxSet, y = 4.1+.1, yend = 4.1+.1, color = Set), size = 1)+
    geom_segment(data = outPltAnnotated.Set, aes(x = xMinSet, xend = xMaxSet, y = -3, yend = -3, color = Set), size = 1)+
    geom_label(data = outPltAnnotated.Set, aes(x = xMeanSet, y = 4.1+.1, label = Set))+
    # x "axis"
#     geom_text(aes(x = xMeanSiteYear, y = -3, label = SiteYear), angle = 90, hjust = 1, size = 2.5)+ # SiteYear
    geom_text(data=outPltAnnotated.Site, aes(x = xMeanSite, y = -3.5, label = Site), angle = 90, hjust = 1, size = 2.5)+
    geom_segment(data = outPltAnnotated.Site, aes(x = xMinSite, xend = xMaxSite, y = -3.45, yend = -3.45, color = everyOtherSite), size = 1)+
    geom_text(data = outPltAnnotated.SiteYear, aes(x = xMeanSiteYear, y =-3.1, label = Year), angle = 90, hjust = 1, size = 2.5)+
    # Observations -----------------------------------------------------------
    rasterise(geom_point(aes(Xcoord, y), size = 0.1, color = 'gray'), data=outPltAnnotated, dpi=use_dpi) + # raw values
#     geom_point(aes(Xcoord, y), size = 0.1, color = 'gray')+ # raw values
    # Residual Env to SiteYear ---------------------------------------------------
    rasterise(geom_segment(aes(x = xMeanSiteYear, xend = xMeanSiteYear, y = yMeanSite, yend = yMeanSiteYear), color = '#dd1c77', size = 0.25), 
              data=outPltAnnotated, dpi=use_dpi)+
    # SiteYear Means --------------------------------------------------------------
    rasterise(geom_segment(data = outPltAnnotated.SiteYear, aes(x = xMinSiteYear, xend = xMaxSiteYear, y = yMeanSiteYear, yend = yMeanSiteYear), color = '#dd1c77', size = 1), 
              data=outPltAnnotated.SiteYear, dpi=use_dpi)+
    # Site Means -------------------------------------------------------------
    rasterise(geom_segment(data = outPltAnnotated.Site, aes(x = xMinSite, xend = xMaxSite, y = yMeanSite, yend = yMeanSite), color = 'black', size = 1), 
              data=outPltAnnotated.Site, dpi=use_dpi)+
    labs(y = 'Normalize Yield')+    
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.major.y = element_line(colour = 'darkgray'),
          panel.grid.minor.x = element_blank(),
          panel.grid.minor.y = element_line(colour = 'darkgray'),
          legend.position = ''
         )+
    scale_color_manual(values = c('white', 'Black', # Colors for alternating bar on x
                                  'Black', 'Gray'   # Colors for train/test
                                 ))+
    coord_cartesian(ylim = c(-4.15, 4.1))

variability_chart
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:51.912004Z', start_time: '2023-07-13T19:11:03.390Z'}
marginal_boxplot <- ggplot(outPltAnnotated)+
    geom_boxplot(aes(y = y, fill = Set), alpha = 0.6)+
    geom_boxplot(aes(y = y, group = Set), fill = NA)+
    scale_fill_manual(values = c('Gray', 'Black'))+
    labs(y = '')+    
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.major.y = element_line(colour = 'darkgray'),
          panel.grid.minor.x = element_blank(),
          panel.grid.minor.y = element_line(colour = 'darkgray'),
          legend.position = ''
         )+
    coord_cartesian(ylim = c(-4.15, 4.1))


marginal_density <- ggplot(outPltAnnotated)+
    geom_density(aes(y = y, color = Set))+
    scale_color_manual(values = c('Gray', 'Black'))+
    labs(y = '')+    
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.major.y = element_line(colour = 'darkgray'),
          panel.grid.minor.x = element_blank(),
          panel.grid.minor.y = element_line(colour = 'darkgray'),
          legend.position = ''
         )+
    coord_cartesian(ylim = c(-4.15, 4.1))


layout = paste(c(rep('A', times = 47), "BCC"), collapse = '')
full_plt <- variability_chart+marginal_boxplot+marginal_density+plot_layout(design = layout)
full_plt
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:51.919029Z', start_time: '2023-07-13T19:11:03.393Z'}
# ggsave(filename = '../output/variability_chart.pdf', plot = full_plt, width = 12, height = 7.5)
```

### Fit Random Effects Model for VCA

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:51.925657Z', start_time: '2023-07-13T19:11:03.401Z'}
if( overwrite_saved_files ){
    library(VCA)
    library(tidyverse)
    
    ModTrain <- read.csv('../output/01_mod_train.csv') |> select(-'X')
    ModTest <- read.csv('../output/01_mod_test.csv') |> select(-'X')

    ModAll <- rbind(ModTrain, ModTest) |>
        select(Pedigree, ExperimentCode, Year, y) |>
        unite(SiteYear, ExperimentCode:Year)

    ModAll$SiteYear <- as.factor(ModAll$SiteYear)
    ModAll$Pedigree <- as.factor(ModAll$Pedigree)
    print(Sys.time())
    fit <- remlMM(y ~ 1+(Pedigree)+(SiteYear)+(Pedigree):(SiteYear), ModAll, cov = TRUE)
    print(Sys.time())

    write.csv(fit$aov.tab, './vca_mod_aov_tab.csv')

    save(fit, file = "vca_mod.rda")

    print(fit$aov.tab)

    load("vca_mod.rda")

    print(fit$aov.tab)    
}
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:51.962771Z', start_time: '2023-07-13T19:11:03.405Z'}
# read in the VCA table results

res <- read.csv('./vca_mod_aov_tab.csv')

mk_PrVarPlot <- function(res = read.csv('./vca_mod_aov_tab.csv')){
    PrVarPlot <- res |>
        rename(`Model Term` = X) |>
        filter(`Model Term` != 'total') |>
#         mutate(`Model Term` = case_when(`Model Term` == 'error' ~ 'Error',
#                                  `Model Term` != 'error' ~ `Model Term`)) |>
#         mutate(`Model Term` = factor(`Model Term`, levels = c('Error', 'SiteYear', 'Pedigree:SiteYear', 'Pedigree'))) |>
        mutate(`Model Term` = case_when(`Model Term` == 'error' ~ 'Err.',
                                        `Model Term` == 'SiteYear' ~ 'E', 
                                        `Model Term` == 'Pedigree:SiteYear' ~ 'GxE', 
                                        `Model Term` == 'Pedigree' ~ 'G')) |>
        mutate(`Model Term` = factor(`Model Term`, levels = c('Err.', 'E', 'GxE', 'G'))) |>

    
        
        arrange(desc(`Model Term`)) |>
        mutate(C.X.Total = cumsum(X.Total)) |>
        mutate(X.Total.Lab = paste0(as.character(round(X.Total, 3)), '%')) |>
        ggplot(aes(y = `VC`, x = '1'))+
            geom_bar(aes(fill = `Model Term`), position = 'fill', stat="identity")+
            geom_label(aes(y = (C.X.Total/100)-(VC/2), label = X.Total.Lab))+
            scale_fill_manual(values = c('#f2f0f7', '#43a2ca', '#7bccc4', '#31a354'))+
            scale_y_continuous(labels = scales::percent)+
            labs(y = 'Proportion of Variance')+
            theme(legend.position = 'bottom',
                  axis.title.x = element_blank(),
                  axis.text.x = element_blank(),
                  panel.grid.major.x = element_blank(),
                  panel.grid.minor.x = element_blank()
                  )
    return(PrVarPlot)    
}


# Takes at least >3 h to run
# PrVarPlot_train <- mk_PrVarPlot(res = read.csv('./vca_mod_aov_tab_trainonly.csv'))
PrVarPlot_test <- mk_PrVarPlot(res = read.csv('./vca_mod_aov_tab.csv'))
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:51.969627Z', start_time: '2023-07-13T19:11:03.409Z'}
# ggsave(filename = '../output/ProportionVariance_test.pdf', plot = PrVarPlot_test, width = 4, height = 7.5)
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:12:57.643380Z', start_time: '2023-07-13T19:11:03.415Z'}
layout = paste(
    c(rep('A', times = 100), 
    rep('B', times = 2), 
#     rep('C', times = 3), 
    rep('D', times = 10)), collapse = '')
      
full_plt <- ((variability_chart+labs(title = "A. Variability of Yield"))+
             (marginal_boxplot)+
#              (marginal_density)+
             (PrVarPlot_test+labs(title = "B. Variance Explained")))+plot_layout(design = layout)

full_plt
```

```{r}
#| ExecuteTime: {end_time: '2023-07-13T19:13:02.183438Z', start_time: '2023-07-13T19:11:03.418Z'}
ggsave(filename = '../output/SFigure_Variability.pdf', plot = full_plt, width = 18, height = 8)
```

# Simulation Study 
Demonstrate ensembling benefit between two models in simple simulation (for reviewer comment).

```{r}
# library(tidyverse)
# library(patchwork)

run_sim_ensemble <- function(
    mean1 = 0,
    mean2 = 1, 
    var1 = 5,
    var2 = 10,
    xs = seq(0, 100, length.out = 100000)
  ){
    n <- length(xs)
    ys <- 0+1*xs
    y1 <- ys + rnorm(n = n, mean = mean1, sd = sqrt(var1))
    y2 <- ys + rnorm(n = n, mean = mean2, sd = sqrt(var2))

    yhat_vars  <- unlist(map(list(y1, y2), function(e){var(e)}))
    yhat_stds  <- unlist(map(list(y1, y2), function(e){sqrt(var(e))}))
    yhat_rmses <- unlist(map(list(y1, y2), function(e){sqrt((sum((ys-e)**2)/n))}))
    wght_vars  <- (1/yhat_vars)/sum(1/yhat_vars)
    wght_stds  <- (1/yhat_stds)/sum(1/yhat_stds)
    wght_rmses <- (1/yhat_rmses)/sum(1/yhat_rmses)

    e1 <- 0.5*y1 + 0.5*y2
    e2 <- wght_vars[1]*y1 + wght_vars[2]*y2
    e3 <- wght_stds[1]*y1 + wght_stds[2]*y2
    e4 <- wght_rmses[1]*y1 + wght_rmses[2]*y2

    data <- data.frame(
        xs, ys, y1, y2, 
        unif = e1, 
        var = e2, 
        std = e3,
        rmse = e4)

    plt_data <- data |> 
        select(-xs) |> 
        pivot_longer(cols = c(y1, y2, unif, var, std, rmse)) |> 
        rename(y_pred = value) |> 
        # Calc RMSE
        group_by(name) |>                
        mutate(y_se = (ys - y_pred)**2) |> 
        summarise(y_rmse = sqrt(mean(y_se))) |> 
        ungroup() |> 
        mutate(mean1 = mean1,
               mean2 = mean2,
               var1 = var1,
               var2 = var2)

    return(plt_data)
}
```

```{r}
sim_data_same_mean <- do.call(
    rbind, 
    map(c(seq(0.01, 4.9, by = 0.01), seq(5, 50, by = 1)), 
        function(i){
            run_sim_ensemble(
                mean1 = 0,
                mean2 = 0, 
                var1 = 1,
                var2 = i,
                xs = seq(0, 100, length.out = 100000)
            )
        }
       )
) 
```

```{r}
cleaned_sim_same_mean <- sim_data_same_mean |> 
    mutate(line_type = case_when(((name != 'var') & (name != 'std')) ~ 'solid',
                                 name == 'var' ~ 'dashed',
                                 name == 'std' ~ 'dotted')) |> 
    mutate(line_type = factor(line_type, levels= c('solid', 'dashed', 'dotted'))) |>
    mutate(name = case_when(name == 'rmse' ~ 'RMSE', 
                           name == 'unif' ~ 'Unif', 
                           name == 'var' ~ 'Var', 
                           name == 'std' ~ 'StD', 
                           name == 'y1' ~ 'Model 1',
                           name == 'y2' ~ 'Model 2' 
                           )) |>
    mutate(name = factor(name, levels = c('RMSE', 'Unif', 'Var', 'StD', 'Model 1', 'Model 2'))) 
```

```{r}
plt1.1 <- cleaned_sim_same_mean |>
    ggplot()+
    geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type), size = 1)+
    theme_classic()+
    theme(legend.position = '')+
    labs(x = 'Model 2 Error Variance',
         y = 'RMSE of Predictions',
         title = 'A. Zoomed Region')+
    scale_color_manual(values = c('orange', 'red', 'blue', 'cornflowerblue', 'gray', 'black'))+
    coord_cartesian(xlim = c(0, 1.1), ylim = c(0, 1.1))

plt1.2 <- cleaned_sim_same_mean |>
    ggplot()+
    geom_line(aes(x = var2, y = y_rmse, color = name, linetype = line_type), size = 1)+
    theme_classic()+
    labs(x = 'Model 2 Error Variance',
         y = 'RMSE of Predictions',
         title = 'B. Full Graph')+
    scale_color_manual(values = c('orange', 'red', 'blue', 'cornflowerblue', 'gray', 'black'))



layout ="AAAB"
multiplt <- plt1.1 + plt1.2 +plot_layout(design = layout)
multiplt
```

